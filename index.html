<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Music Player</title>

<link rel="manifest" href="/manifest.json">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Music Player">
<link rel="apple-touch-icon" href="/icons/icon-192x192.png"> <style>
  /* Reset */
  * {
    box-sizing: border-box;
  }

  :root {
    --primary-color: #ff6f61; /* Define a CSS variable for the primary color */
  }

  body {
    margin: 0;
    background-color: #121212;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    justify-content: center;
    padding: 20px;
    min-height: 100vh;
  }

  #player-container {
    background: #1e1e1e;
    width: 360px;
    border-radius: 16px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    user-select: none;
  }

  .controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 14px;
    padding: 15px 20px;
    background: #272727;
    border-bottom: 1px solid #333;
  }

  .controls button {
    background: #333;
    border: none;
    border-radius: 50%;
    width: 42px;
    height: 42px;
    color: #eee;
    font-size: 18px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .controls button:hover,
  .controls button:focus {
    background-color: var(--primary-color); /* Use CSS variable */
    outline: none;
  }

  #play-pause-btn {
    width: 54px;
    height: 54px;
    font-size: 22px;
    background: var(--primary-color); /* Use CSS variable */
    box-shadow: 0 0 10px var(--primary-color)aa; /* Use CSS variable */
  }

  #play-pause-btn:hover,
  #play-pause-btn:focus {
    background: #ff4b3f; /* Keep a slightly different hover for the main button or make it a derived variable */
    box-shadow: 0 0 14px #ff4b3fcc;
  }

  #cover-art {
    width: 100%;
    aspect-ratio: 1/1;
    object-fit: cover;
    border-radius: 0 0 16px 16px;
    box-shadow: inset 0 0 40px #0008;
    margin-bottom: 8px;
    background: #2a2a2a;
  }

  #playlist {
    max-height: 280px;
    overflow-y: auto;
    background: #121212;
    padding: 8px 0;
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) #2a2a2a; /* Use CSS variable */
  }

  #playlist::-webkit-scrollbar {
    width: 8px;
  }

  #playlist::-webkit-scrollbar-thumb {
    background-color: var(--primary-color); /* Use CSS variable */
    border-radius: 4px;
  }

  .playlist-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 20px;
    cursor: pointer;
    transition: background-color 0.25s ease;
    border-left: 4px solid transparent;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    user-select:none;
  }

  .playlist-item:hover {
    background-color: #272727;
  }

  .playlist-item.active {
    background-color: var(--primary-color); /* Use CSS variable */
    border-left-color: #ff4433; /* Keep a slightly different border color or make it a derived variable */
    color: #fff;
  }

  .playlist-item img {
    width: 36px;
    height: 36px;
    object-fit: cover;
    border-radius: 6px;
    box-shadow: 0 0 6px #0005;
    flex-shrink: 0;
  }

  .title-artist {
    display: flex;
    flex-direction: column;
    font-size: 14px;
    overflow: hidden;
  }

  .title-artist .title {
    font-weight: 600;
    color: #fff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .title-artist .artist {
    font-weight: 400;
    color: #ccc;
    font-size: 12px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* New styles for download/delete buttons */
  .download-btn,
  .delete-download-btn {
    margin-left: auto; /* Push buttons to the right */
    background: none;
    border: none;
    color: #eee;
    font-size: 1.2em;
    cursor: pointer;
    opacity: 0.8;
    transition: opacity 0.2s ease;
    padding: 5px; /* Add some padding for easier clicking */
    border-radius: 4px;
  }

  .download-btn:hover,
  .delete-download-btn:hover {
    opacity: 1;
    background-color: rgba(255, 255, 255, 0.1);
  }

  .delete-download-btn {
    color: #f00; /* Red for delete */
  }

  .download-btn:disabled,
  .delete-download-btn:disabled {
    cursor: not-allowed;
    opacity: 0.5;
  }

  #search-input,
  #stream-url-input {
    width: calc(100% - 40px);
    margin: 12px 20px;
    padding: 8px 12px;
    border-radius: 8px;
    border: none;
    font-size: 14px;
    background-color: #272727;
    color: #eee;
    outline: none;
    transition: background-color 0.3s ease;
  }

  #search-input::placeholder,
  #stream-url-input::placeholder {
    color: #777;
  }

  #search-input:focus,
  #stream-url-input:focus {
    background-color: #3c3c3c;
  }

  #play-stream-btn,
  #export-playlist-btn,
  #import-playlist-btn,
  #preload-all-btn, /* Added for preload button */
  #mp3-converter-btn { /* Added for MP3 converter button */
    margin: 0 20px 14px;
    padding: 10px;
    width: calc(100% - 40px);
    border: none;
    border-radius: 10px;
    background-color: var(--primary-color); /* Use CSS variable */
    color: white;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  #play-stream-btn:hover,
  #export-playlist-btn:hover,
  #import-playlist-btn:hover,
  #preload-all-btn:hover, /* Added for preload button */
  #mp3-converter-btn:hover, /* Added for MP3 converter button */
  #play-stream-btn:focus,
  #export-playlist-btn:focus,
  #import-playlist-btn:focus,
  #preload-all-btn:focus, /* Added for preload button */
  #mp3-converter-btn:focus { /* Added for MP3 converter button */
    background-color: #ff4433; /* Keep a slightly different hover or make it a derived variable */
    outline: none;
  }

  #visualizer {
    width: 100%;
    height: 60px;
    background: #181818;
    border-top: 1px solid #333;
  }

  #lang-select,
  #theme-color-picker { /* Add theme color picker here for consistent styling */
    margin: 10px 20px 20px;
    padding: 6px 10px;
    border-radius: 8px;
    background: #272727;
    border: none;
    color: #eee;
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }

  #lang-select:hover,
  #lang-select:focus,
  #theme-color-picker:hover, /* Add theme color picker here */
  #theme-color-picker:focus { /* Add theme color picker here */
    background-color: #3c3c3c;
    outline: none;
  }

  /* Drag & Drop highlight */
  #player-container.dragover {
    border: 3px dashed var(--primary-color); /* Use CSS variable */
  }
</style>
</head>
<body>
<div id="player-container" role="main" aria-label="Music Player" tabindex="0">

  <img id="cover-art" src="" alt="No track playing" />

  <div class="controls" role="region" aria-label="Playback controls">
    <button id="prev-btn" aria-label="Previous track" tabindex="0">‚èÆ</button>
    <button id="play-pause-btn" aria-label="Play/Pause" tabindex="0">‚ñ∂Ô∏è</button>
    <button id="next-btn" aria-label="Next track" tabindex="0">‚è≠</button>
    <button id="shuffle-btn" aria-pressed="false" aria-label="Shuffle toggle" tabindex="0">üîÄ</button>
    <button id="repeat-btn" aria-pressed="false" aria-label="Repeat toggle" tabindex="0">üîÅ</button>
  </div>

  <input id="search-input" type="search" placeholder="Search songs..." aria-label="Search songs" />

  <ul id="playlist" role="list" tabindex="0" aria-label="Playlist"></ul>

  <input id="stream-url-input" type="url" placeholder="Enter streaming URL (mp3/aac)" aria-label="Streaming URL" />
  <button id="play-stream-btn" aria-label="Play stream from URL">Play Stream</button>

  <button id="export-playlist-btn" aria-label="Export playlist">Export Playlist</button>
  <button id="import-playlist-btn" aria-label="Import playlist">Import Playlist</button>
  <input type="file" id="import-file-input" accept=".json" hidden />

  <button id="preload-all-btn" aria-label="Preload all music">Preload All Music</button>
  <button id="mp3-converter-btn" aria-label="Go to MP3 Converter">Go to MP3 Converter</button>

  <canvas id="visualizer" aria-hidden="true"></canvas>

  <select id="lang-select" aria-label="Select language">
    <option value="en" selected>English</option>
    <option value="es">Espa√±ol</option>
    <option value="fr">Fran√ßais</option>
    <option value="de">Deutsch</option>
  </select>

  <input type="color" id="theme-color-picker" value="#ff6f61" aria-label="Choose theme color" />

</div>

<script>
(() => {
  // Localization strings
  const locales = {
    en: {
      searchPlaceholder: "Search songs...",
      streamPlaceholder: "Enter streaming URL (mp3/aac)",
      playStream: "Play Stream",
      exportPlaylist: "Export Playlist",
      importPlaylist: "Import Playlist",
      noTrack: "No track playing",
      shuffle: "Shuffle toggle",
      repeat: "Repeat toggle",
      prevTrack: "Previous track",
      nextTrack: "Next track",
      playPause: "Play/Pause",
      playlist: "Playlist",
      selectLang: "Select language",
      fileNotSupported: "File type not supported. Use mp3, wav, ogg, aac.",
      importError: "Failed to import playlist.",
      noSongsInPlaylist: "No songs in playlist.",
      errorLoadingFile: "Error loading file:",
      downloadTrack: "Download track",
      deleteDownloadedTrack: "Delete downloaded track",
      downloadedAlert: "downloaded!",
      downloadFailedAlert: "Failed to download music. See console for details.",
      deleteDownloadedAlert: "deleted from downloads.",
      deleteFailedAlert: "Failed to delete music. See console for details.",
      mp3Converter: "Go to MP3 Converter", // New string
      preloadAllMusic: "Preload All Music", // New string
      preloadingAll: "Preloading all...", // New string
      preloading: "Preloading", // New string
      preloadComplete: "Preload complete!", // New string
      of: "of", // New string
      tracks: "tracks", // New string
      failedToPreload: "failed to preload", // New string
      noSongsInPlaylistToPreload: "No songs in playlist to preload.", // New string
    },
    es: {
      searchPlaceholder: "Buscar canciones...",
      streamPlaceholder: "Introduce URL de streaming (mp3/aac)",
      playStream: "Reproducir Streaming",
      exportPlaylist: "Exportar Lista",
      importPlaylist: "Importar Lista",
      noTrack: "Ninguna canci√≥n reproducida",
      shuffle: "Alternar aleatorio",
      repeat: "Alternar repetici√≥n",
      prevTrack: "Pista anterior",
      nextTrack: "Siguiente pista",
      playPause: "Reproducir/Pausar",
      playlist: "Lista de reproducci√≥n",
      selectLang: "Seleccionar idioma",
      fileNotSupported: "Tipo de archivo no soportado. Usa mp3, wav, ogg, aac.",
      importError: "Error al importar la lista.",
      noSongsInPlaylist: "No hay canciones en la lista.",
      errorLoadingFile: "Error cargando archivo:",
      downloadTrack: "Descargar pista",
      deleteDownloadedTrack: "Eliminar pista descargada",
      downloadedAlert: "descargado!",
      downloadFailedAlert: "Fallo al descargar la m√∫sica. Ver consola para detalles.",
      deleteDownloadedAlert: "eliminado de las descargas.",
      deleteFailedAlert: "Fallo al eliminar la m√∫sica. Ver consola para detalles.",
      mp3Converter: "Ir al convertidor de MP3", // New string
      preloadAllMusic: "Precargar toda la m√∫sica", // New string
      preloadingAll: "Precargando todo...", // New string
      preloading: "Precargando", // New string
      preloadComplete: "¬°Precarga completa!", // New string
      of: "de", // New string
      tracks: "canciones", // New string
      failedToPreload: "fallaron al precargar", // New string
      noSongsInPlaylistToPreload: "No hay canciones en la lista para precargar.", // New string
    },
    fr: {
      searchPlaceholder: "Rechercher des chansons...",
      streamPlaceholder: "Entrez l'URL de streaming (mp3/aac)",
      playStream: "Lire le flux",
      exportPlaylist: "Exporter la liste",
      importPlaylist: "Importer la liste",
      noTrack: "Aucune piste en cours",
      shuffle: "Activer le mode al√©atoire",
      repeat: "Activer la r√©p√©tition",
      prevTrack: "Piste pr√©c√©dente",
      nextTrack: "Piste suivante",
      playPause: "Lecture/Pause",
      playlist: "Liste de lecture",
      selectLang: "Choisir la langue",
      fileNotSupported: "Type de fichier non pris en charge. Utilisez mp3, wav, ogg, aac.",
      importError: "√âchec de l'importation de la liste.",
      noSongsInPlaylist: "Aucune chanson dans la liste.",
      errorLoadingFile: "Erreur de chargement du fichier :",
      downloadTrack: "T√©l√©charger la piste",
      deleteDownloadedTrack: "Supprimer la piste t√©l√©charg√©e",
      downloadedAlert: "t√©l√©charg√© !",
      downloadFailedAlert: "√âchec du t√©l√©chargement de la musique. Voir la console pour plus de d√©tails.",
      deleteDownloadedAlert: "supprim√© des t√©l√©chargements.",
      deleteFailedAlert: "√âchec de la suppression de la musique. Voir la console pour plus de d√©tails.",
      mp3Converter: "Aller au convertisseur MP3", // New string
      preloadAllMusic: "Pr√©charger toute la musique", // New string
      preloadingAll: "Pr√©chargement en cours...", // New string
      preloading: "Pr√©chargement", // New string
      preloadComplete: "Pr√©chargement termin√© !", // New string
      of: "de", // New string
      tracks: "pistes", // New string
      failedToPreload: "n'ont pas pu √™tre pr√©charg√©es", // New string
      noSongsInPlaylistToPreload: "Aucune chanson dans la playlist √† pr√©charger.", // New string
    },
    de: {
      searchPlaceholder: "Songs suchen...",
      streamPlaceholder: "Streaming-URL eingeben (mp3/aac)",
      playStream: "Stream abspielen",
      exportPlaylist: "Playlist exportieren",
      importPlaylist: "Playlist importieren",
      noTrack: "Kein Titel l√§uft",
      shuffle: "Shuffle ein-/ausschalten",
      repeat: "Wiederholung ein-/ausschalten",
      prevTrack: "Vorheriger Titel",
      nextTrack: "N√§chster Titel",
      playPause: "Abspielen/Pause",
      playlist: "Playlist",
      selectLang: "Sprache w√§hlen",
      fileNotSupported: "Dateityp nicht unterst√ºtzt. Verwenden Sie mp3, wav, ogg, aac.",
      importError: "Import der Playlist fehlgeschlagen.",
      noSongsInPlaylist: "Keine Lieder in der Playlist.",
      errorLoadingFile: "Fehler beim Laden der Datei:",
      downloadTrack: "Titel herunterladen",
      deleteDownloadedTrack: "Heruntergeladenen Titel l√∂schen",
      downloadedAlert: "heruntergeladen!",
      downloadFailedAlert: "Fehler beim Herunterladen der Musik. Details in der Konsole.",
      deleteDownloadedAlert: "aus Downloads gel√∂scht.",
      deleteFailedAlert: "Fehler beim L√∂schen der Musik. Details in der Konsole.",
      mp3Converter: "Zum MP3-Konverter", // New string
      preloadAllMusic: "Alle Musik vorladen", // New string
      preloadingAll: "Lade alles vor...", // New string
      preloading: "Vorladen", // New string
      preloadComplete: "Vorladen abgeschlossen!", // New string
      of: "von", // New string
      tracks: "Titel", // New string
      failedToPreload: "konnten nicht vorgeladen werden", // New string
      noSongsInPlaylistToPreload: "Keine Titel in der Playlist zum Vorladen.", // New string
    },
  };

  // Elements
  const container = document.getElementById('player-container');
  const coverArt = document.getElementById('cover-art');
  const playPauseBtn = document.getElementById('play-pause-btn');
  const prevBtn = document.getElementById('prev-btn');
  const nextBtn = document.getElementById('next-btn');
  const shuffleBtn = document.getElementById('shuffle-btn');
  const repeatBtn = document.getElementById('repeat-btn');
  const playlistEl = document.getElementById('playlist');
  const searchInput = document.getElementById('search-input');
  const streamUrlInput = document.getElementById('stream-url-input');
  const playStreamBtn = document.getElementById('play-stream-btn');
  const exportPlaylistBtn = document.getElementById('export-playlist-btn');
  const importPlaylistBtn = document.getElementById('import-playlist-btn');
  const importFileInput = document.getElementById('import-file-input');
  const visualizerCanvas = document.getElementById('visualizer');
  const langSelect = document.getElementById('lang-select');
  const themeColorPicker = document.getElementById('theme-color-picker');
  const mp3ConverterBtn = document.getElementById('mp3-converter-btn'); // New element
  const preloadAllBtn = document.getElementById('preload-all-btn'); // New element

  let locale = locales.en;

  // Audio & state
  const audio = new Audio();
  let playlist = [];
  let filteredPlaylist = [];
  let currentIndex = -1;
  let isPlaying = false;
  let shuffle = false;
  let repeat = false;

  // Audio context for visualization
  let audioCtx, analyser, source, dataArray, animationId;

  // IndexedDB Constants
  const IDB_DATABASE_NAME = 'music-db';
  const IDB_STORE_NAME = 'tracks';

  // Helper: default cover art SVG as base64 data URI
  const defaultCoverArt = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDUwIDUwIiBmaWxsPSIjNjY2NjY2IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSIyNSIgY3k9IjI1IiByPSIyMCIgZmlsbD0iI2NjY2NjYyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNiA2IiBzdHJva2U9IiM0MDQwNDAiIHN0cm9rZS13aWR0aD0iNSIvPgo8cGF0aCBkPSJNMjUgMTVsNiA2LTYgNm0wIDEwbDYgNm0tNi02LTYgNiIgZmlsbD0iIzc3N2Y3ZiIvPgo8L3N2Zz4=`;

  // Set default UI text based on locale
  function updateLocaleTexts() {
    searchInput.placeholder = locale.searchPlaceholder;
    streamUrlInput.placeholder = locale.streamPlaceholder;
    playStreamBtn.textContent = locale.playStream;
    exportPlaylistBtn.textContent = locale.exportPlaylist;
    importPlaylistBtn.textContent = locale.importPlaylist;
    playPauseBtn.setAttribute('aria-label', locale.playPause);
    prevBtn.setAttribute('aria-label', locale.prevTrack);
    nextBtn.setAttribute('aria-label', locale.nextTrack);
    shuffleBtn.setAttribute('aria-label', locale.shuffle);
    repeatBtn.setAttribute('aria-label', locale.repeat);
    playlistEl.setAttribute('aria-label', locale.playlist);
    langSelect.setAttribute('aria-label', locale.selectLang);
    mp3ConverterBtn.textContent = locale.mp3Converter; // New: MP3 Converter button text
    preloadAllBtn.textContent = locale.preloadAllMusic; // New: Preload All Music button text

    if(currentIndex === -1) coverArt.alt = locale.noTrack;
  }

  updateLocaleTexts();

  // Utilities
  function isSupportedFileType(fileName) {
    return /\.(mp3|wav|ogg|aac)$/i.test(fileName);
  }

  // Extract basic metadata from file or URL (title from filename)
  // For simplicity, no ID3 parsing, just filename for title
  function createTrackObject(fileOrUrl) {
    let title = '', artist = '', url = '', cover = defaultCoverArt;
    if(typeof fileOrUrl === 'string') {
      // Streaming URL
      url = fileOrUrl;
      title = url.split('/').pop().split('?')[0] || 'Streaming Track';
      artist = '';
    } else {
      // File object
      url = URL.createObjectURL(fileOrUrl);
      title = fileOrUrl.name.replace(/\.[^/.]+$/, "");
      artist = '';
    }
    // Add new properties for download feature
    return {title, artist, url, cover, isDownloaded: false, offlineUrl: null};
  }

  // Helper to open IndexedDB
  async function openIndexedDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(IDB_DATABASE_NAME, 1); // Version 1

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(IDB_STORE_NAME)) {
          db.createObjectStore(IDB_STORE_NAME, { keyPath: 'id' });
        }
      };

      request.onsuccess = (event) => {
        resolve(event.target.result);
      };

      request.onerror = (event) => {
        console.error('IndexedDB error:', event.target.error);
        reject(event.target.error);
      };
    });
  }

  // Function to download and store a track
  async function downloadAndStoreTrack(track) {
    if (!track || !track.url) {
      console.error('Invalid track object for download:', track);
      return false;
    }
    if (track.isDownloaded) {
        console.log(`Track "${track.title}" is already downloaded.`);
        return true; // Already downloaded, consider it a success for this operation
    }

    // Generate a unique ID for the track in IndexedDB based on original URL hash or a unique identifier
    // For simplicity, let's use a combination of URL hash and timestamp
    const trackId = `track_${btoa(track.url).replace(/=/g, '')}_${Date.now()}`;


    try {
      const db = await openIndexedDB();
      const response = await fetch(track.url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const audioBlob = await response.blob();
      const mimeType = response.headers.get('Content-Type') || 'audio/mpeg';

      const transaction = db.transaction([IDB_STORE_NAME], 'readwrite');
      const store = transaction.objectStore(IDB_STORE_NAME);

      // Store the audio blob and original metadata
      const dataToStore = {
        id: trackId, // Unique ID for IndexedDB
        title: track.title,
        artist: track.artist,
        originalUrl: track.url, // Keep original URL
        audioBlob: audioBlob,
        mimeType: mimeType,
        cover: track.cover || defaultCoverArt,
      };

      await store.add(dataToStore);

      // Update the original playlist item to point to the IndexedDB URL
      const originalTrackIndex = playlist.findIndex(t => t.url === track.url);
      if (originalTrackIndex !== -1) {
        playlist[originalTrackIndex].offlineUrl = `indexeddb://${trackId}`; // Custom URL scheme
        playlist[originalTrackIndex].isDownloaded = true;
        renderPlaylist(); // Re-render to update UI (e.g., show delete button)
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error downloading and storing track:', error);
      alert(`${locale.downloadFailedAlert}`);
      return false;
    }
  }

  // Function to delete a track from IndexedDB
  async function deleteStoredTrack(track) {
      if (!track || !track.offlineUrl) return false;

      const urlObj = new URL(track.offlineUrl);
      if (urlObj.protocol !== 'indexeddb:') {
          console.warn('Track is not an IndexedDB URL, cannot delete:', track.offlineUrl);
          return false;
      }
      const trackId = urlObj.hostname; // The hostname is our ID

      try {
          const db = await openIndexedDB();
          const transaction = db.transaction([IDB_STORE_NAME], 'readwrite');
          const store = transaction.objectStore(IDB_STORE_NAME);

          await store.delete(trackId);

          // Update the original playlist item
          const originalTrackIndex = playlist.findIndex(t => t.offlineUrl === track.offlineUrl);
          if (originalTrackIndex !== -1) {
              delete playlist[originalTrackIndex].offlineUrl; // Remove offline URL
              playlist[originalTrackIndex].isDownloaded = false;
              renderPlaylist(); // Re-render to update UI
              return true;
          }
          return false;
      } catch (error) {
          console.error('Error deleting track from IndexedDB:', error);
          alert(`${locale.deleteFailedAlert}`);
          return false;
      }
  }

  // Function to check if a track is downloaded
  async function isTrackDownloaded(track) {
    if (!track || !track.url) return false;

    try {
      const db = await openIndexedDB();
      const transaction = db.transaction([IDB_STORE_NAME], 'readonly');
      const store = transaction.objectStore(IDB_STORE_NAME);
      
      // Iterate through store to find matching originalUrl
      return new Promise((resolve) => {
        const request = store.openCursor();
        request.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            if (cursor.value.originalUrl === track.url) {
              // Update the playlist track's offlineUrl and isDownloaded status
              track.offlineUrl = `indexeddb://${cursor.value.id}`;
              track.isDownloaded = true;
              resolve(true);
              return;
            }
            cursor.continue();
          } else {
            resolve(false);
          }
        };
        request.onerror = () => {
          console.error("Error checking download status:", event.target.error);
          resolve(false);
        };
      });
    } catch (error) {
        console.error("Could not open IndexedDB to check download status:", error);
        return false;
    }
  }

  // Populate playlist with tracks and update download status
  async function checkAllTracksDownloadStatus() {
    // We need to re-check all tracks, especially after loading a playlist
    // This will update the `isDownloaded` and `offlineUrl` properties directly on `playlist` objects
    for (const track of playlist) {
      await isTrackDownloaded(track);
    }
    renderPlaylist(); // Re-render after all statuses are updated
  }

  // New: Function to preload all tracks in the playlist
  async function preloadAllMusic() {
    if (playlist.length === 0) {
        alert(locale.noSongsInPlaylistToPreload);
        return;
    }

    preloadAllBtn.disabled = true;
    preloadAllBtn.textContent = locale.preloadingAll;

    let downloadedCount = 0;
    let failedCount = 0;

    for (const track of playlist) {
        // Check if already downloaded to avoid re-downloading
        if (track.isDownloaded) {
            downloadedCount++;
            continue;
        }

        const success = await downloadAndStoreTrack(track); // Use the existing download function
        if (success) {
            downloadedCount++;
        } else {
            failedCount++;
        }
        // Update button text to show progress
        preloadAllBtn.textContent = `${locale.preloading} (${downloadedCount}/${playlist.length})`;
    }

    preloadAllBtn.disabled = false;
    preloadAllBtn.textContent = locale.preloadAllMusic; // Reset text

    let message = `${locale.preloadComplete} ${downloadedCount} ${locale.of} ${playlist.length} ${locale.tracks}.`;
    if (failedCount > 0) {
        message += ` ${failedCount} ${locale.failedToPreload}.`;
    }
    alert(message);
  }


  // Render playlist items filtered by searchInput.value
  function renderPlaylist() {
    playlistEl.innerHTML = '';

    const searchTerm = searchInput.value.trim().toLowerCase();

    filteredPlaylist = playlist.filter(track => {
      return (
        track.title.toLowerCase().includes(searchTerm) ||
        track.artist.toLowerCase().includes(searchTerm)
      );
    });

    if(filteredPlaylist.length === 0) {
      const emptyMsg = document.createElement('li');
      emptyMsg.textContent = locale.noSongsInPlaylist;
      emptyMsg.style.padding = '10px 20px';
      emptyMsg.style.color = '#777';
      playlistEl.appendChild(emptyMsg);
      return;
    }

    filteredPlaylist.forEach((track, idx) => {
      const item = document.createElement('li');
      item.className = 'playlist-item';
      item.tabIndex = 0;
      item.dataset.idx = playlist.indexOf(track); // store original index

      if(playlist.indexOf(track) === currentIndex) {
        item.classList.add('active');
      }

      const img = document.createElement('img');
      img.src = track.cover || defaultCoverArt;
      img.alt = "";

      const titleArtist = document.createElement('div');
      titleArtist.className = 'title-artist';

      const titleEl = document.createElement('div');
      titleEl.className = 'title';
      titleEl.textContent = track.title;

      const artistEl = document.createElement('div');
      artistEl.className = 'artist';
      artistEl.textContent = track.artist;

      titleArtist.appendChild(titleEl);
      titleArtist.appendChild(artistEl);

      item.appendChild(img);
      item.appendChild(titleArtist);

      // Download button
      const downloadBtn = document.createElement('button');
      downloadBtn.className = 'download-btn';
      downloadBtn.setAttribute('aria-label', locale.downloadTrack);
      downloadBtn.textContent = '‚¨áÔ∏è';
      downloadBtn.addEventListener('click', async (e) => {
          e.stopPropagation(); // Prevent playing the track when clicking download
          downloadBtn.disabled = true;
          downloadBtn.textContent = '‚è≥'; // Indicate downloading
          const success = await downloadAndStoreTrack(track);
          if (success) {
              alert(`"${track.title}" ${locale.downloadedAlert}`);
          }
          // Re-render playlist to update button visibility
          // checkAllTracksDownloadStatus(); // This will also call renderPlaylist
      });
      item.appendChild(downloadBtn);

      // Delete downloaded button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'delete-download-btn';
      deleteBtn.setAttribute('aria-label', locale.deleteDownloadedTrack);
      deleteBtn.textContent = 'üóëÔ∏è';
      deleteBtn.style.display = 'none'; // Hidden by default
      deleteBtn.addEventListener('click', async (e) => {
          e.stopPropagation(); // Prevent playing the track when clicking delete
          deleteBtn.disabled = true;
          const success = await deleteStoredTrack(track);
          if (success) {
              alert(`"${track.title}" ${locale.deleteDownloadedAlert}`);
          }
          // Re-render playlist to update button visibility
          // checkAllTracksDownloadStatus(); // This will also call renderPlaylist
      });
      item.appendChild(deleteBtn);

      // Set initial button visibility based on isDownloaded status
      if (track.isDownloaded) {
        downloadBtn.style.display = 'none';
        deleteBtn.style.display = 'block';
      } else {
        downloadBtn.style.display = 'block';
        deleteBtn.style.display = 'none';
      }

      // Click or keyboard to select
      item.addEventListener('click', () => {
        // If track is downloaded, play from offlineUrl, otherwise play from original URL
        const urlToPlay = track.isDownloaded ? track.offlineUrl : track.url;
        playTrack(playlist.indexOf(track), urlToPlay); // Pass URL to play
      });
      item.addEventListener('keydown', (e) => {
        if(e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          const urlToPlay = track.isDownloaded ? track.offlineUrl : track.url;
          playTrack(playlist.indexOf(track), urlToPlay);
        }
      });

      playlistEl.appendChild(item);
    });
  }

  // Load & play a track by index
  // Modify playTrack function to accept a URL to play
  function playTrack(idx, urlToPlay = null) {
    if(idx < 0 || idx >= playlist.length) return;

    currentIndex = idx;
    const track = playlist[currentIndex];
    audio.src = urlToPlay || track.url; // Use provided URL or original URL
    audio.play().catch((e) => {
        console.error("Audio playback failed:", e);
        alert("Failed to play track. Make sure your browser allows autoplay or try interacting with the page first.");
    });
    isPlaying = true;
    updatePlayPauseButton();
    updateCoverArt(track.cover);
    updatePlaylistActive();
  }

  // Play next track
  function playNext() {
    if(playlist.length === 0) return;

    if(shuffle) {
      let nextIdx;
      do {
        nextIdx = Math.floor(Math.random() * playlist.length);
      } while (nextIdx === currentIndex && playlist.length > 1);
      playTrack(nextIdx, playlist[nextIdx].isDownloaded ? playlist[nextIdx].offlineUrl : playlist[nextIdx].url);
    } else {
      if(currentIndex + 1 < playlist.length) {
        playTrack(currentIndex + 1, playlist[currentIndex + 1].isDownloaded ? playlist[currentIndex + 1].offlineUrl : playlist[currentIndex + 1].url);
      } else if(repeat) {
        playTrack(0, playlist[0].isDownloaded ? playlist[0].offlineUrl : playlist[0].url);
      } else {
        pauseAudio();
      }
    }
  }

  // Play previous track
  function playPrev() {
    if(playlist.length === 0) return;

    if(shuffle) {
      let prevIdx;
      do {
        prevIdx = Math.floor(Math.random() * playlist.length);
      } while (prevIdx === currentIndex && playlist.length > 1);
      playTrack(prevIdx, playlist[prevIdx].isDownloaded ? playlist[prevIdx].offlineUrl : playlist[prevIdx].url);
    } else {
      if(currentIndex > 0) {
        playTrack(currentIndex - 1, playlist[currentIndex - 1].isDownloaded ? playlist[currentIndex - 1].offlineUrl : playlist[currentIndex - 1].url);
      } else if(repeat) {
        playTrack(playlist.length - 1, playlist[playlist.length - 1].isDownloaded ? playlist[playlist.length - 1].offlineUrl : playlist[playlist.length - 1].url);
      } else {
        pauseAudio();
      }
    }
  }

  // Toggle play/pause
  function togglePlayPause() {
    if(isPlaying) {
      pauseAudio();
    } else {
      if(currentIndex === -1 && playlist.length > 0) {
        // If no track selected, play the first one, respecting download status
        playTrack(0, playlist[0].isDownloaded ? playlist[0].offlineUrl : playlist[0].url);
      } else if (currentIndex !== -1) {
        // Play the currently selected track, respecting download status
        playTrack(currentIndex, playlist[currentIndex].isDownloaded ? playlist[currentIndex].offlineUrl : playlist[currentIndex].url);
      } else {
          // No tracks loaded, cannot play
          console.log("No tracks available to play.");
      }
    }
  }

  function pauseAudio() {
    audio.pause();
    isPlaying = false;
    updatePlayPauseButton();
  }

  // Update UI play/pause icon
  function updatePlayPauseButton() {
    playPauseBtn.textContent = isPlaying ? "‚è∏" : "‚ñ∂Ô∏è";
  }

  // Update cover art
  function updateCoverArt(url) {
    coverArt.src = url || defaultCoverArt;
    coverArt.alt = isPlaying && currentIndex !== -1 ? playlist[currentIndex].title : locale.noTrack;
  }

  // Update active playlist item highlight
  function updatePlaylistActive() {
    const items = playlistEl.querySelectorAll('.playlist-item');
    items.forEach(item => {
      item.classList.remove('active');
      if(parseInt(item.dataset.idx, 10) === currentIndex) {
        item.classList.add('active');
        // Scroll into view smoothly
        item.scrollIntoView({behavior: 'smooth', block: 'nearest'});
      }
    });
  }

  // Shuffle toggle
  function toggleShuffle() {
    shuffle = !shuffle;
    shuffleBtn.setAttribute('aria-pressed', shuffle);
    shuffleBtn.style.color = shuffle ? 'var(--primary-color)' : '';
  }

  // Repeat toggle
  function toggleRepeat() {
    repeat = !repeat;
    repeatBtn.setAttribute('aria-pressed', repeat);
    repeatBtn.style.color = repeat ? 'var(--primary-color)' : '';
  }

  // Play streaming URL (no download support for this yet in current implementation)
  function playStream() {
    const url = streamUrlInput.value.trim();
    if(!url) return;
    audio.src = url;
    audio.play().catch(() => {});
    isPlaying = true;
    currentIndex = -1; // Streaming doesn't tie to playlist
    updatePlayPauseButton();
    updateCoverArt(defaultCoverArt);
    updatePlaylistActive(); // Clear active state
  }

  // Export playlist to JSON file
  function exportPlaylist() {
    if(playlist.length === 0) {
      alert(locale.noSongsInPlaylist);
      return;
    }
    // Only export relevant track data, not the actual Blob
    const exportablePlaylist = playlist.map(track => ({
      title: track.title,
      artist: track.artist,
      url: track.url, // Original URL
      cover: track.cover,
      // Do not export offlineUrl or audioBlob
    }));

    const json = JSON.stringify(exportablePlaylist, null, 2);
    const blob = new Blob([json], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "playlist.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // Import playlist from JSON file
  function importPlaylistFromFile(file) {
    if(!file) return;
    const reader = new FileReader();
    reader.onload = async e => { // Make async to await checkAllTracksDownloadStatus
      try {
        const imported = JSON.parse(e.target.result);
        if(Array.isArray(imported)) {
          // Basic validation and transformation to match track object structure
          playlist = imported.map(t => ({
              title: t.title || 'Unknown Title',
              artist: t.artist || 'Unknown Artist',
              url: t.url,
              cover: t.cover || defaultCoverArt,
              isDownloaded: false, // Reset download status on import
              offlineUrl: null,
          })).filter(t => t.url); // Ensure valid URL
          currentIndex = -1;
          isPlaying = false;
          audio.pause();
          audio.src = "";
          updateCoverArt(defaultCoverArt);
          // After rendering, check download status for imported tracks
          await checkAllTracksDownloadStatus();
          updatePlayPauseButton();
        } else {
          alert(locale.importError);
        }
      } catch (error) {
        console.error("Import playlist error:", error);
        alert(locale.importError);
      }
    };
    reader.readAsText(file);
  }

  // Drag & drop handlers for files
  function onDragOver(e) {
    e.preventDefault();
    container.classList.add('dragover');
  }
  function onDragLeave(e) {
    e.preventDefault();
    container.classList.remove('dragover');
  }
  function onDrop(e) {
    e.preventDefault();
    container.classList.remove('dragover');
    const files = Array.from(e.dataTransfer.files);
    const accepted = files.filter(f => isSupportedFileType(f.name));
    if(accepted.length === 0) {
      alert(locale.fileNotSupported);
      return;
    }
    // Add to playlist
    accepted.forEach(file => {
      const track = createTrackObject(file);
      playlist.push(track);
    });
    // After adding, check download status for new tracks
    checkAllTracksDownloadStatus();
  }

  // Keyboard shortcuts
  function onKeyDown(e) {
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

    switch(e.key.toLowerCase()) {
      case ' ':
        e.preventDefault();
        togglePlayPause();
        break;
      case 'arrowright':
        e.preventDefault();
        playNext();
        break;
      case 'arrowleft':
        e.preventDefault();
        playPrev();
        break;
      case 's':
        e.preventDefault();
        toggleShuffle();
        break;
      case 'r':
        e.preventDefault();
        toggleRepeat();
        break;
    }
  }

  // Visualizer setup
  function setupVisualizer() {
    try {
      audioCtx = new AudioContext();
      analyser = audioCtx.createAnalyser();
      source = audioCtx.createMediaElementSource(audio);
      source.connect(analyser);
      analyser.connect(audioCtx.destination);
      analyser.fftSize = 256;
      const bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array(bufferLength);

      const canvasCtx = visualizerCanvas.getContext('2d');
      const WIDTH = visualizerCanvas.width = visualizerCanvas.clientWidth;
      const HEIGHT = visualizerCanvas.height = visualizerCanvas.clientHeight;

      function draw() {
        animationId = requestAnimationFrame(draw);
        analyser.getByteFrequencyData(dataArray);

        canvasCtx.fillStyle = '#181818';
        canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

        const barWidth = (WIDTH / bufferLength) * 1.5;
        let x = 0;
        for(let i = 0; i < bufferLength; i++) {
          const barHeight = dataArray[i] / 2;
          // Get the current primary color from the CSS variable
          const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
          canvasCtx.fillStyle = primaryColor;
          canvasCtx.fillRect(x, HEIGHT - barHeight, barWidth, barHeight);
          x += barWidth + 1;
        }
      }

      draw();
    } catch(e) {
      console.warn("Visualizer not supported or audio context could not be started.", e);
    }
  }

  // Resize visualizer canvas on window resize
  window.addEventListener('resize', () => {
    if(visualizerCanvas) {
      visualizerCanvas.width = visualizerCanvas.clientWidth;
      visualizerCanvas.height = visualizerCanvas.clientHeight;
    }
  });

  // Initialize
  function init() {
    // Event listeners
    playPauseBtn.addEventListener('click', togglePlayPause);
    prevBtn.addEventListener('click', playPrev);
    nextBtn.addEventListener('click', playNext);
    shuffleBtn.addEventListener('click', toggleShuffle);
    repeatBtn.addEventListener('click', toggleRepeat);
    searchInput.addEventListener('input', renderPlaylist);
    playStreamBtn.addEventListener('click', playStream);
    exportPlaylistBtn.addEventListener('click', exportPlaylist);
    importPlaylistBtn.addEventListener('click', () => importFileInput.click());
    importFileInput.addEventListener('change', e => {
      importPlaylistFromFile(e.target.files[0]);
      importFileInput.value = '';
    });
    mp3ConverterBtn.addEventListener('click', () => { // New: MP3 Converter button
        window.open('https://www.freeconvert.com/mp3-converter', '_blank'); // Opens in new tab
    });
    preloadAllBtn.addEventListener('click', preloadAllMusic); // New: Preload All Music button

    container.addEventListener('dragover', onDragOver);
    container.addEventListener('dragleave', onDragLeave);
    container.addEventListener('drop', onDrop);

    window.addEventListener('keydown', onKeyDown);

    audio.addEventListener('ended', playNext);
    audio.addEventListener('play', () => {
      isPlaying = true;
      updatePlayPauseButton();
      // Resume audio context if suspended
      if(audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    });
    audio.addEventListener('pause', () => {
      isPlaying = false;
      updatePlayPauseButton();
    });

    langSelect.addEventListener('change', () => {
      const val = langSelect.value;
      locale = locales[val] || locales.en;
      updateLocaleTexts();
      renderPlaylist();
    });

    themeColorPicker.addEventListener('input', (e) => {
      document.documentElement.style.setProperty('--primary-color', e.target.value);
      updatePlaylistActive();
    });

    updateCoverArt(defaultCoverArt);
    renderPlaylist(); // Initial render of the playlist (might be empty)
    checkAllTracksDownloadStatus(); // Then check and update download status for all tracks
    setupVisualizer();

    // Service Worker Registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered with scope:', registration.scope);
          })
          .catch((error) => {
            console.error('Service Worker registration failed:', error);
          });
      });
    }
  }

  init();

})();
</script>
</body>
</html>
