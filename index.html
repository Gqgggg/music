<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Music Player</title>

<link rel="manifest" href="/manifest.json">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Music Player">
<link rel="apple-touch-icon" href="/icons/icon-192x192.png">

<style>
  /* Reset */
  * {
    box-sizing: border-box;
  }

  :root {
    --primary-color: #ff6f61; /* Define a CSS variable for the primary color */
    --background-dark: #121212;
    --background-medium: #1e1e1e;
    --background-light: #272727;
    --text-color: #eee;
    --text-muted: #aaa;
    --border-color: #2a2a2a;
    --shadow-color: rgba(0, 0, 0, 0.6);
    --primary-color-rgb: 255, 111, 97; /* Default RGB for primary color */
  }

  body {
    margin: 0;
    background-color: var(--background-dark);
    color: var(--text-color);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center; /* Center vertically */
    padding: 20px;
    min-height: 100vh;
    overflow-y: auto; /* Allow scrolling if content is taller than viewport */
  }

  #player-container {
    background: var(--background-medium);
    width: 360px;
    max-width: 100%; /* Ensure responsiveness on smaller screens */
    border-radius: 16px;
    box-shadow: 0 10px 30px var(--shadow-color); /* Enhanced shadow */
    overflow: hidden;
    display: flex;
    flex-direction: column;
    user-select: none;
    margin: auto; /* Center horizontally if max-width is hit */
  }

  /* Section Grouping Styles - Renamed to features-group */
  .features-group {
    padding: 15px 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    border-top: 1px solid var(--border-color);
  }

  .features-group:first-of-type {
    border-top: none;
  }

  .features-group h3 {
    margin: 0;
    color: var(--primary-color);
    font-size: 1.1em; /* Slightly larger heading */
    text-transform: uppercase;
    letter-spacing: 0.8px; /* More prominent spacing */
    padding-bottom: 5px; /* Space below heading */
  }

  /* Cover Art & Controls */
  #player-header {
    position: relative; /* For current song info overlay */
    background: var(--background-medium);
  }

  #cover-art {
    width: 100%;
    aspect-ratio: 1/1;
    object-fit: cover;
    display: block; /* Remove extra space below image */
    box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.8); /* Darker inner shadow */
    background: #2a2a2a;
  }

  #current-song-info {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
    padding: 20px 20px 10px 20px; /* More padding at bottom */
    color: #fff;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    opacity: 0; /* Hidden by default */
    transition: opacity 0.3s ease-in-out;
  }

  #player-header:hover #current-song-info {
    opacity: 1; /* Show on hover */
  }

  #current-song-info .title {
    font-size: 1.2em; /* Larger title */
    font-weight: 700;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  #current-song-info .artist {
    font-size: 0.9em;
    color: #ccc;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  #playback-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 14px;
    padding: 15px 20px;
    background: var(--background-light); /* Slightly lighter for controls */
    border-top: 1px solid var(--border-color);
    position: relative; /* For progress bar positioning */
  }

  #progress-bar-container {
    position: absolute;
    top: 0; /* Position at the very top of the controls div */
    left: 0;
    width: 100%;
    height: 6px; /* Slimmer progress bar */
    background-color: #383838;
    cursor: pointer;
    border-radius: 3px 3px 0 0; /* Rounded top corners */
  }

  #progress-bar {
    height: 100%;
    width: 0%;
    background-color: var(--primary-color);
    border-radius: 3px 3px 0 0;
    transition: width 0.1s linear; /* Smoother progress animation */
  }

  #playback-controls button {
    background: #333;
    border: none;
    border-radius: 50%;
    width: 42px;
    height: 42px;
    color: var(--text-color);
    font-size: 18px;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease; /* Add transform transition */
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3); /* Subtle button shadow */
  }

  #playback-controls button:hover,
  #playback-controls button:focus {
    background-color: var(--primary-color);
    outline: none;
    transform: translateY(-2px); /* Slight lift on hover */
  }

  #play-pause-btn {
    width: 54px;
    height: 54px;
    font-size: 22px;
    background: var(--primary-color);
    box-shadow: 0 0 12px rgba(var(--primary-color-rgb), 0.6); /* More pronounced glow */
  }

  #play-pause-btn:hover,
  #play-pause-btn:focus {
    background: #ff4b3f;
    box-shadow: 0 0 16px rgba(var(--primary-color-rgb), 0.8);
    transform: scale(1.05); /* Slightly larger on hover */
  }

  /* Tab Navigation */
  #tab-navigation {
    display: flex;
    background: var(--background-light);
    border-top: 1px solid var(--border-color);
  }

  #tab-navigation button {
    flex: 1;
    padding: 15px 0;
    background: none;
    border: none;
    color: var(--text-muted);
    font-size: 1.1em;
    font-weight: 600;
    cursor: pointer;
    transition: color 0.3s ease, background-color 0.3s ease;
    border-bottom: 3px solid transparent;
    outline: none;
  }

  #tab-navigation button.active {
    color: var(--primary-color);
    border-bottom-color: var(--primary-color);
    background-color: var(--background-medium);
  }

  #tab-navigation button:hover:not(.active) {
    color: var(--text-color);
    background-color: #333;
  }

  /* Tab Content */
  .tab-content {
    display: none; /* Hidden by default */
    background: var(--background-dark);
    flex-grow: 1; /* Allow content to take available space */
    min-height: 200px; /* Ensure a minimum height for tab content */
  }

  .tab-content.active {
    display: flex; /* Show active tab */
    flex-direction: column;
  }

  #search-input {
    width: calc(100% - 40px);
    margin: 15px 20px 0px 20px; /* Adjusted top margin */
    padding: 10px 15px; /* More padding */
    border-radius: 10px; /* Slightly more rounded */
    border: none;
    font-size: 15px; /* Slightly larger font */
    background-color: var(--background-light);
    color: var(--text-color);
    outline: none;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
  }

  #search-input::placeholder {
    color: #777;
  }

  #search-input:focus {
    background-color: #3c3c3c;
    box-shadow: 0 0 0 2px var(--primary-color); /* Focus ring */
  }

  /* Active Filter Display */
  #active-filter-display {
    padding: 10px 20px;
    background-color: var(--background-light);
    color: var(--text-color);
    font-size: 0.9em;
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    margin-top: 15px;
    opacity: 0; /* Hidden by default */
    transition: opacity 0.3s ease;
  }

  #active-filter-display.active {
    opacity: 1;
  }

  #active-filter-display button {
    background: none;
    border: none;
    color: var(--primary-color);
    font-size: 1em;
    cursor: pointer;
    transition: color 0.2s ease;
  }
  #active-filter-display button:hover {
    color: #fff;
  }


  #playlist {
    max-height: 280px; /* Still maintains height within tab */
    overflow-y: auto;
    background: var(--background-dark);
    padding: 8px 0;
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) #2a2a2a;
    border-top: none; /* No border top within tab content */
    list-style: none; /* Remove default list bullets */
    flex-grow: 1; /* Allow playlist to take remaining height */
  }

  #playlist::-webkit-scrollbar {
    width: 8px;
  }

  #playlist::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 4px;
  }

  .playlist-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 20px;
    cursor: pointer;
    transition: background-color 0.25s ease, transform 0.1s ease;
    border-left: 4px solid transparent;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    user-select:none;
    position: relative;
    padding-right: 120px; /* Make space for the new controls */
  }

  .playlist-item:hover {
    background-color: #272727;
    transform: translateX(3px); /* Subtle slide on hover */
  }

  .playlist-item.active {
    background-color: rgba(var(--primary-color-rgb), 0.2); /* Semi-transparent primary */
    border-left-color: var(--primary-color);
    color: var(--text-color);
  }

  /* Dragging feedback */
  .playlist-item.dragging {
    opacity: 0.5;
    border: 2px dashed var(--primary-color);
    background-color: rgba(var(--primary-color-rgb), 0.1);
  }

  .playlist-item.drag-over-placeholder {
    border-top: 2px solid var(--primary-color);
    padding-top: 12px; /* Adjust padding to make space for the line */
  }


  .playlist-item img {
    width: 40px; /* Slightly larger image */
    height: 40px;
    object-fit: cover;
    border-radius: 8px; /* More rounded corners */
    box-shadow: 0 2px 8px rgba(0,0,0,0.4); /* Enhanced image shadow */
    flex-shrink: 0;
  }

  .title-artist {
    display: flex;
    flex-direction: column;
    font-size: 14px;
    overflow: hidden;
    flex-grow: 1; /* Allow title/artist to take available space */
  }

  .title-artist .title {
    font-weight: 600;
    color: #fff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .title-artist .artist {
    font-weight: 400;
    color: var(--text-muted); /* Use muted text color */
    font-size: 12px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Download/Delete/Edit buttons */
  .download-btn,
  .delete-download-btn,
  .edit-info-btn {
    background: none;
    border: none;
    color: var(--text-muted); /* Muted color */
    font-size: 1.2em;
    cursor: pointer;
    opacity: 0.7; /* Slightly less opaque */
    transition: opacity 0.2s ease, transform 0.2s ease;
    padding: 5px;
    border-radius: 4px;
    flex-shrink: 0; /* Prevent shrinking */
  }

  .download-btn:hover,
  .download-btn:focus,
  .delete-download-btn:hover,
  .delete-download-btn:focus,
  .edit-info-btn:hover,
  .edit-info-btn:focus {
    opacity: 1;
    background-color: rgba(255, 255, 255, 0.15); /* Slightly brighter hover */
    outline: none;
    transform: scale(1); /* Pop out slightly */
  }

  .delete-download-btn {
    color: #ff4b3f; /* Red for delete */
  }

  .download-btn:disabled,
  .delete-download-btn:disabled,
  .edit-info-btn:disabled {
    cursor: not-allowed;
    opacity: 0.3; /* More faded when disabled */
    transform: none; /* No transform when disabled */
  }

  /* Playlist management buttons */
  .playlist-item-controls {
      display: flex;
      gap: 5px;
      align-items: center;
      margin-left: 10px; /* Small margin to separate from download/delete */
      flex-shrink: 0; /* Prevent shrinking */
  }

  .playlist-item-controls button {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1em;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s ease, transform 0.2s ease;
      padding: 5px;
      border-radius: 4px;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 30px;
      height: 30px;
  }

  .playlist-item-controls button:hover {
      opacity: 1;
      background-color: rgba(255, 255, 255, 0.15);
      transform: scale(1.05);
  }

  .playlist-item-controls .remove-from-playlist-btn {
      color: #ff6f61;
  }

  .playlist-item-controls .remove-from-playlist-btn:hover {
      background-color: rgba(255, 111, 97, 0.25);
  }

  .playlist-item-controls button:disabled {
    cursor: not-allowed;
    opacity: 0.3;
    transform: none;
  }


  /* Action Buttons & Inputs (General Styling) */
  .features-group input[type="url"],
  .features-group button,
  .library-filter-nav button,
  #playback-speed-select { /* Added playback-speed-select */
    width: 100%;
    padding: 10px;
    border: none;
    border-radius: 10px;
    background-color: var(--primary-color);
    color: white;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3); /* Button shadows */
  }

  .features-group input[type="url"],
  #playback-speed-select { /* Added playback-speed-select */
    background-color: var(--background-light);
    color: var(--text-color);
    font-weight: normal;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3); /* Inset shadow for inputs */
  }

  .features-group input[type="url"]::placeholder {
    color: #777;
  }

  .features-group input[type="url"]:focus,
  #playback-speed-select:focus { /* Added playback-speed-select */
    background-color: #3c3c3c;
    box-shadow: 0 0 0 2px var(--primary-color), inset 0 1px 3px rgba(0,0,0,0.3);
  }

  .features-group button:hover,
  .features-group button:focus,
  .library-filter-nav button:hover,
  .library-filter-nav button:focus { /* Added library filter buttons */
    background-color: #ff4433;
    outline: none;
    transform: translateY(-2px); /* Lift button on hover */
    box-shadow: 0 4px 10px rgba(0,0,0,0.4);
  }

  .features-group button:active,
  .library-filter-nav button:active { /* Added library filter buttons */
    transform: translateY(0); /* Press effect */
    box-shadow: 0 1px 3px rgba(0,0,0,0.4);
  }

  /* Library Browser Section */
  #library-browser {
    border-top: 1px solid var(--border-color);
    padding: 15px 20px;
    flex-grow: 1; /* Allows it to take available space within the tab */
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  #library-browser h3 {
    margin: 0;
    color: var(--primary-color);
    font-size: 1.1em;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    padding-bottom: 5px;
  }

  #library-filter-nav {
    display: flex;
    gap: 10px;
    flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
  }

  #library-filter-nav button {
    flex: 1; /* Distribute space evenly */
    min-width: 80px; /* Ensure buttons don't get too small */
    background-color: var(--background-light);
    color: var(--text-color);
    box-shadow: none; /* No shadow by default for these */
    font-weight: normal;
    transition: background-color 0.2s ease, color 0.2s ease;
  }

  #library-filter-nav button.active {
    background-color: var(--primary-color);
    color: white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    transform: none; /* No lift when active */
  }

  #library-filter-nav button:hover:not(.active) {
    background-color: #3c3c3c;
    transform: none;
    box-shadow: none;
  }

  #library-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 250px; /* Limit height if many items */
    overflow-y: auto;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background-color: var(--background-light);
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) #2a2a2a;
    flex-grow: 1; /* Take remaining space */
  }

  #library-list::-webkit-scrollbar {
    width: 8px;
  }

  #library-list::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 4px;
  }

  .library-list-item {
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s ease;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 1.1em;
  }
  .library-list-item:last-child {
    border-bottom: none;
  }
  .library-list-item:hover {
    background-color: #333;
  }
  .library-list-item span {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-grow: 1;
  }
  .library-list-item .count {
    color: var(--text-muted);
    font-size: 0.9em;
    margin-left: 10px;
    flex-shrink: 0;
  }


  /* Visualizer */
  #visualizer {
    width: 100%;
    height: 60px;
    background: #181818;
    border-top: 1px solid var(--border-color);
  }

  /* Settings Section */
  #settings-section {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
  }

  #lang-select,
  #theme-color-picker {
    flex-grow: 1;
    padding: 8px 12px; /* More padding */
    border-radius: 10px; /* More rounded */
    background: var(--background-light);
    border: none;
    color: var(--text-color);
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
  }

  #lang-select:hover,
  #lang-select:focus,
  #theme-color-picker:hover,
  #theme-color-picker:focus {
    background-color: #3c3c3c;
    outline: none;
    box-shadow: 0 0 0 2px var(--primary-color), inset 0 1px 3px rgba(0,0,0,0.3);
  }

  #theme-color-picker {
    width: 50px; /* Fixed width for color picker */
    height: 38px; /* Adjust height to match select */
    padding: 0;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    border: 1px solid var(--border-color); /* Add a border to picker */
    overflow: hidden; /* Hide default color input style */
  }

  #theme-color-picker::-webkit-color-swatch-wrapper {
      padding: 0;
  }
  #theme-color-picker::-webkit-color-swatch {
      border: none;
      border-radius: 8px; /* Match outer border radius */
  }
  #theme-color-picker::-moz-color-swatch, #theme-color-picker::-moz-focus-inner {
      border: none;
      border-radius: 8px;
  }

  /* Drag & Drop highlight */
  #player-container.dragover {
    border: 3px dashed var(--primary-color);
    box-shadow: 0 0 20px rgba(var(--primary-color-rgb), 0.5); /* Glowing border */
  }

  /* Loading Indicator Styles */
  #loading-indicator {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent overlay */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000; /* Ensure it's on top of other content */
    color: var(--text-color);
    font-size: 1.2em;
    backdrop-filter: blur(5px); /* Optional: adds a blur effect */
  }

  #loading-indicator.hidden {
    display: none;
  }

  .spinner {
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-top: 4px solid var(--primary-color);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite; /* Spin animation */
    margin-bottom: 10px;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* Media Queries for Responsiveness */
  @media (max-width: 400px) {
    body {
      padding: 10px;
    }
    #player-container {
      border-radius: 0; /* Full width on very small screens */
      height: 100vh; /* Fill screen height on mobile */
      width: 100%;
    }
    .features-group {
      padding: 10px 15px;
    }
    #playback-controls {
      gap: 10px;
      padding: 10px 15px;
    }
    #playback-controls button {
      width: 38px;
      height: 38px;
      font-size: 16px;
    }
    #play-pause-btn {
      width: 48px;
      height: 48px;
      font-size: 20px;
    }
    #search-input {
      width: calc(100% - 30px);
      margin: 10px 15px 0px 15px; /* Adjusted margin */
    }
    .playlist-item {
      padding: 8px 15px;
    }
    .playlist-item img {
      width: 32px;
      height: 32px;
    }
    .title-artist .title {
      font-size: 13px;
    }
    .title-artist .artist {
      font-size: 11px;
    }
    .download-btn, .delete-download-btn, .edit-info-btn, .playlist-item-controls button {
      font-size: 1em;
      width: 28px;
      height: 28px;
    }
    #current-song-info .title {
      font-size: 1.1em;
    }
    #current-song-info .artist {
      font-size: 0.8em;
    }
    #tab-navigation button {
      font-size: 1em;
      padding: 12px 0;
    }
    #library-browser {
      padding: 10px 15px;
      gap: 10px;
    }
    #library-filter-nav {
      gap: 5px;
    }
    #library-filter-nav button {
      padding: 8px;
      min-width: unset;
    }
    .library-list-item {
      padding: 10px 12px;
      font-size: 1em;
    }
  }
</style>
</head>
<body>
<div id="player-container" role="main" aria-label="Music Player" tabindex="0">
  <div id="player-header">
    <img id="cover-art" src="" alt="No track playing" />
    <div id="current-song-info">
      <div class="title" id="current-song-title"></div>
      <div class="artist" id="current-song-artist"></div>
    </div>
  </div>

  <div id="playback-controls" role="region" aria-label="Playback controls">
    <div id="progress-bar-container">
      <div id="progress-bar"></div>
    </div>
    <button id="prev-btn" aria-label="Previous track" tabindex="0">⏮</button>
    <button id="play-pause-btn" aria-label="Play/Pause" tabindex="0">▶️</button>
    <button id="next-btn" aria-label="Next track" tabindex="0">⏭</button>
    <button id="shuffle-btn" aria-pressed="false" aria-label="Shuffle toggle" tabindex="0">🔀</button>
    <button id="repeat-btn" aria-pressed="false" aria-label="Repeat toggle" tabindex="0">🔁</button>
  </div>

  <div id="tab-navigation" role="tablist" aria-label="Music Player Tabs">
    <button id="library-tab-btn" role="tab" aria-selected="true" aria-controls="library-tab-content" tabindex="0">Library</button>
    <button id="playlist-tab-btn" role="tab" aria-selected="false" aria-controls="playlist-tab-content" tabindex="-1">Playlist</button>
  </div>

  <div id="library-tab-content" class="tab-content active" role="tabpanel" aria-labelledby="library-tab-btn">
    <div id="library-browser">
      <h3>Browse Library</h3>
      <div id="library-filter-nav">
        <button id="view-all-songs-btn">All Songs</button>
        <button id="view-albums-btn">Albums</button>
        <button id="view-artists-btn">Artists</button>
        <button id="view-genres-btn">Genres</button>
      </div>
      <ul id="library-list"></ul>
    </div>

    <div id="stream-section" class="features-group">
      <h3>Stream Music</h3>
      <input id="stream-url-input" type="url" placeholder="Enter streaming URL (mp3/aac)" aria-label="Streaming URL" />
      <button id="play-stream-btn" aria-label="Play stream from URL">Play Stream</button>
    </div>

    <div id="file-management-section" class="features-group">
      <h3>File Management</h3>
      <button id="add-music-btn" aria-label="Add songs from device">Add Songs from Device</button>
      <input type="file" id="add-music-file-input" accept="audio/*" multiple hidden />
      <button id="export-playlist-btn" aria-label="Export playlist">Export Playlist</button>
      <button id="import-playlist-btn" aria-label="Import playlist">Import Playlist</button>
      <input type="file" id="import-file-input" accept=".json" hidden />
    </div>

    <div id="tools-section" class="features-group">
      <h3>Tools</h3>
      <button id="preload-all-btn" aria-label="Preload all music">Preload All Music</button>
      <button id="mp3-converter-btn" aria-label="Go to MP3 Converter">Go to MP3 Converter</button>
    </div>
  </div>

  <div id="playlist-tab-content" class="tab-content" role="tabpanel" aria-labelledby="playlist-tab-btn" style="display: none;">
    <div id="active-filter-display">
      <span id="current-filter-text"></span>
      <button id="clear-filter-btn">Clear Filter</button>
    </div>
    <input id="search-input" type="search" placeholder="Search songs..." aria-label="Search songs" />
    <ul id="playlist" role="list" tabindex="0" aria-label="Playlist"></ul>
  </div>

  <canvas id="visualizer" aria-hidden="true"></canvas>

  <div id="settings-section" class="features-group">
    <h3>Settings</h3>
    <select id="lang-select" aria-label="Select language">
      <option value="en" selected>English</option>
      <option value="es">Español</option>
      <option value="fr">Français</option>
      <option value="de">Deutsch</option>
    </select>
    <input type="color" id="theme-color-picker" value="#ff6f61" aria-label="Choose theme color" />
  </div>

  <div class="features-group">
    <h3>Playback Speed</h3>
    <select id="playback-speed-select" aria-label="Select playback speed">
      <option value="0.5">0.5x</option>
      <option value="0.75">0.75x</option>
      <option value="1.0" selected>1.0x (Normal)</option>
      <option value="1.25">1.25x</option>
      <option value="1.5">1.5x</option>
      <option value="1.75">1.75x</option>
      <option value="2.0">2.0x</option>
    </select>
  </div>
</div>

<div id="loading-indicator" class="hidden">
  <div class="spinner"></div>
  <p>Loading music...</p>
</div>

<script>
  (function() {
    // --- IndexedDB Setup ---
    const DB_NAME = 'MusicPlayerDB';
    const DB_VERSION = 2; // Increased version for new object store
    const OBJECT_STORE_NAME = 'tracks';
    let db;

    async function openIndexedDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
          db = event.target.result;
          console.log('IndexedDB upgrade needed. Old version:', event.oldVersion, 'New version:', event.newVersion);

          if (!db.objectStoreNames.contains(OBJECT_STORE_NAME)) {
            const objectStore = db.createObjectStore(OBJECT_STORE_NAME, { keyPath: 'id', autoIncrement: true });
            objectStore.createIndex('title', 'title', { unique: false });
            objectStore.createIndex('artist', 'artist', { unique: false });
            objectStore.createIndex('album', 'album', { unique: false });
            objectStore.createIndex('genre', 'genre', { unique: false });
            console.log('Object store "tracks" created with indices.');
          }

          // If upgrading from a version that didn't have certain features, add them here
          if (event.oldVersion < 2) {
              if (!db.objectStoreNames.contains('settings')) {
                  db.createObjectStore('settings', { keyPath: 'name' });
                  console.log('Object store "settings" created.');
              }
          }
        };

        request.onsuccess = (event) => {
          db = event.target.result;
          console.log('IndexedDB opened successfully.');
          resolve(db);
        };

        request.onerror = (event) => {
          console.error('IndexedDB error:', event.target.error);
          reject(event.target.error);
        };
      });
    }

    // --- DOM Elements ---
    const playerContainer = document.getElementById('player-container');
    const coverArt = document.getElementById('cover-art');
    const currentSongTitle = document.getElementById('current-song-title');
    const currentSongArtist = document.getElementById('current-song-artist');
    const prevBtn = document.getElementById('prev-btn');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const nextBtn = document.getElementById('next-btn');
    const shuffleBtn = document.getElementById('shuffle-btn');
    const repeatBtn = document.getElementById('repeat-btn');
    const progressBarContainer = document.getElementById('progress-bar-container');
    const progressBar = document.getElementById('progress-bar');
    const libraryTabBtn = document.getElementById('library-tab-btn');
    const playlistTabBtn = document.getElementById('playlist-tab-btn');
    const libraryTabContent = document.getElementById('library-tab-content');
    const playlistTabContent = document.getElementById('playlist-tab-content');
    const addMusicBtn = document.getElementById('add-music-btn');
    const addMusicFileInput = document.getElementById('add-music-file-input');
    const streamUrlInput = document.getElementById('stream-url-input');
    const playStreamBtn = document.getElementById('play-stream-btn');
    const playlistUl = document.getElementById('playlist');
    const libraryListUl = document.getElementById('library-list');
    const searchInput = document.getElementById('search-input');
    const viewAllSongsBtn = document.getElementById('view-all-songs-btn');
    const viewAlbumsBtn = document.getElementById('view-albums-btn');
    const viewArtistsBtn = document.getElementById('view-artists-btn');
    const viewGenresBtn = document.getElementById('view-genres-btn');
    const activeFilterDisplay = document.getElementById('active-filter-display');
    const currentFilterText = document.getElementById('current-filter-text');
    const clearFilterBtn = document.getElementById('clear-filter-btn');
    const visualizerCanvas = document.getElementById('visualizer');
    const langSelect = document.getElementById('lang-select');
    const themeColorPicker = document.getElementById('theme-color-picker');
    const preloadAllBtn = document.getElementById('preload-all-btn');
    const mp3ConverterBtn = document.getElementById('mp3-converter-btn');
    const exportPlaylistBtn = document.getElementById('export-playlist-btn');
    const importPlaylistBtn = document.getElementById('import-playlist-btn');
    const importFileInput = document.getElementById('import-file-input');
    const playbackSpeedSelect = document.getElementById('playback-speed-select');
    const loadingIndicator = document.getElementById('loading-indicator');

    let audio = new Audio();
    let currentTrackIndex = -1;
    let playlist = [];
    let library = []; // All available tracks, including those not in current playlist
    let isShuffling = false;
    let repeatMode = 'none'; // 'none', 'one', 'all'
    let currentFilter = { type: 'all', value: null };
    let audioContext;
    let analyser;
    let sourceNode;
    let animationFrameId; // To store the requestAnimationFrame ID
    let currentPlayingFile = null; // Store the currently playing File object or URL

    // --- Utility Functions ---
    function formatTime(seconds) {
      if (isNaN(seconds) || seconds < 0) return "00:00";
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = Math.floor(seconds % 60);
      return `${minutes < 10 ? '0' : ''}${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
    }

    function showLoadingIndicator(message = 'Loading...') {
        loadingIndicator.classList.remove('hidden');
        loadingIndicator.querySelector('p').textContent = message;
    }

    function hideLoadingIndicator() {
        loadingIndicator.classList.add('hidden');
    }

    // --- IndexedDB Operations ---
    async function addTrackToIndexedDB(track) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([OBJECT_STORE_NAME], 'readwrite');
            const objectStore = transaction.objectStore(OBJECT_STORE_NAME);
            const request = objectStore.add(track);

            request.onsuccess = (event) => {
                console.log('Track added to IndexedDB:', track);
                track.id = event.target.result; // Update track with its new ID
                resolve(track);
            };

            request.onerror = (event) => {
                console.error('Error adding track to IndexedDB:', event.target.error);
                reject(event.target.error);
            };
        });
    }

    async function loadTracksFromIndexedDB() {
      return new Promise((resolve, reject) => {
        if (!db) {
          console.warn('IndexedDB not open, cannot load tracks.');
          return resolve([]);
        }
        const transaction = db.transaction([OBJECT_STORE_NAME], 'readonly');
        const objectStore = transaction.objectStore(OBJECT_STORE_NAME);
        const request = objectStore.getAll();

        request.onsuccess = (event) => {
          library = event.target.result || [];
          playlist = [...library]; // Initialize playlist with all library tracks
          console.log('Tracks loaded from IndexedDB:', library);
          resolve(library);
        };

        request.onerror = (event) => {
          console.error('Error loading tracks from IndexedDB:', event.target.error);
          reject(event.target.error);
        };
      });
    }

    async function deleteTrackFromIndexedDB(id) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([OBJECT_STORE_NAME], 'readwrite');
            const objectStore = transaction.objectStore(OBJECT_STORE_NAME);
            const request = objectStore.delete(id);

            request.onsuccess = () => {
                console.log(`Track with ID ${id} deleted from IndexedDB.`);
                resolve();
            };

            request.onerror = (event) => {
                console.error(`Error deleting track with ID ${id} from IndexedDB:`, event.target.error);
                reject(event.target.error);
            };
        });
    }

    async function updateTrackInIndexedDB(track) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([OBJECT_STORE_NAME], 'readwrite');
            const objectStore = transaction.objectStore(OBJECT_STORE_NAME);
            const request = objectStore.put(track); // Use put to update existing or add new

            request.onsuccess = () => {
                console.log('Track updated in IndexedDB:', track);
                resolve(track);
            };

            request.onerror = (event) => {
                console.error('Error updating track in IndexedDB:', event.target.error);
                reject(event.target.error);
            };
        });
    }

    async function saveSetting(name, value) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(['settings'], 'readwrite');
            const store = transaction.objectStore('settings');
            const request = store.put({ name, value });
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject(event.target.error);
        });
    }

    async function loadSetting(name) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(['settings'], 'readonly');
            const store = transaction.objectStore('settings');
            const request = store.get(name);
            request.onsuccess = (event) => resolve(event.target.result ? event.target.result.value : null);
            request.onerror = (event) => reject(event.target.error);
        });
    }

    // --- Audio Player Core Functions ---
    async function playCurrentTrack() {
        if (playlist.length === 0) {
            updatePlayerInfo('No track playing', '');
            coverArt.src = '';
            playPauseBtn.textContent = '▶️';
            audio.src = '';
            currentTrackIndex = -1;
            renderPlaylist(); // Clear active state
            return;
        }

        const track = playlist[currentTrackIndex];
        if (!track) {
            console.error("No track at currentTrackIndex:", currentTrackIndex);
            updatePlayerInfo('Error loading track', 'Please select another');
            return;
        }

        audio.pause();
        currentPlayingFile = track.file || track.src; // Use stored File object or URL
        if (track.file instanceof File) {
            audio.src = URL.createObjectURL(track.file);
        } else {
            audio.src = track.src;
        }
        audio.playbackRate = parseFloat(playbackSpeedSelect.value); // Apply playback speed
        audio.load(); // Load the new source
        audio.play().catch(error => {
            console.error('Error playing audio:', error);
            alert('Failed to play track. It might be an invalid file or streaming URL. See console for details.');
            playPauseBtn.textContent = '▶️';
        });

        updatePlayerInfo(track.title, track.artist);
        updateCoverArt(track.coverArt);
        playPauseBtn.textContent = '⏸';
        renderPlaylist(); // Update active item in playlist UI
        connectSourceToVisualizer(); // Reconnect visualizer for new source
    }

    function togglePlayPause() {
      if (audio.paused) {
        if (currentTrackIndex === -1 && playlist.length > 0) {
          currentTrackIndex = 0; // Start from the beginning if nothing is selected
        }
        if (currentTrackIndex !== -1) {
          playCurrentTrack();
        } else if (audio.src) { // If there's a loaded stream or local file paused
            audio.play().catch(e => console.error("Error resuming play:", e));
            playPauseBtn.textContent = '⏸';
        }
      } else {
        audio.pause();
        playPauseBtn.textContent = '▶️';
      }
    }

    function playNextTrack() {
      if (playlist.length === 0) return;

      if (isShuffling) {
        let newIndex;
        do {
          newIndex = Math.floor(Math.random() * playlist.length);
        } while (newIndex === currentTrackIndex && playlist.length > 1); // Avoid playing same song twice in a row if more than one song exists
        currentTrackIndex = newIndex;
      } else {
        currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
      }
      playCurrentTrack();
    }

    function playPrevTrack() {
      if (playlist.length === 0) return;
      if (audio.currentTime > 3) { // Restart current track if more than 3 seconds in
        audio.currentTime = 0;
      } else {
        if (isShuffling) {
          let newIndex;
          do {
            newIndex = Math.floor(Math.random() * playlist.length);
          } while (newIndex === currentTrackIndex && playlist.length > 1);
          currentTrackIndex = newIndex;
        } else {
          currentTrackIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
        }
      }
      playCurrentTrack();
    }

    function toggleShuffle() {
      isShuffling = !isShuffling;
      shuffleBtn.classList.toggle('active', isShuffling);
      shuffleBtn.setAttribute('aria-pressed', isShuffling);
      saveSetting('isShuffling', isShuffling);
      console.log('Shuffle:', isShuffling ? 'On' : 'Off');
    }

    function toggleRepeat() {
      const modes = ['none', 'one', 'all'];
      let currentIndex = modes.indexOf(repeatMode);
      repeatMode = modes[(currentIndex + 1) % modes.length];
      repeatBtn.setAttribute('aria-pressed', repeatMode !== 'none');

      // Update button text/icon based on mode
      if (repeatMode === 'none') {
        repeatBtn.textContent = '🔁';
        repeatBtn.title = 'Repeat Off';
      } else if (repeatMode === 'one') {
        repeatBtn.textContent = '🔂'; // Repeat one symbol
        repeatBtn.title = 'Repeat One';
      } else { // 'all'
        repeatBtn.textContent = '🔁'; // Repeat all symbol
        repeatBtn.title = 'Repeat All';
      }
      saveSetting('repeatMode', repeatMode);
      console.log('Repeat Mode:', repeatMode);
    }

    function updatePlayerInfo(title, artist) {
      currentSongTitle.textContent = title;
      currentSongArtist.textContent = artist;
    }

    function updateCoverArt(base64Image) {
      if (base64Image) {
        coverArt.src = base64Image;
      } else {
        coverArt.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodGgxMDAiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI2EwYTBhMCI+PHBhdGggZD0iTTEyIDJDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTAgMTZjLTMuMzEgMC02LTIuNjktNi02czIuNjktNiA2LTYgNiAyLjY5IDYgNi0yLjY5IDYtNiA2em0wLTguNWMtMS45MyAwLTMuNSAxLjU3LTMuNSAzLjVzMS41NyAzLjUgMy41IDMuNSAzLjUtMS41NyAzLjUtMy41LTEuNTctMy41LTMuNS0zLjV6Ii8+PC9zdmc+'; // Default icon
      }
    }

    // --- Playlist & Library Rendering ---
    function renderPlaylist() {
      playlistUl.innerHTML = '';
      if (playlist.length === 0) {
        const noSongsMessage = document.createElement('p');
        noSongsMessage.id = 'no-playlist-message';
        noSongsMessage.className = 'no-songs-message';
        noSongsMessage.textContent = 'Your playlist is empty. Add some music from the Library or by streaming!';
        playlistUl.appendChild(noSongsMessage);
        return;
      }

      playlist.forEach((track, index) => {
        const li = document.createElement('li');
        li.className = 'playlist-item';
        li.setAttribute('draggable', 'true');
        li.dataset.id = track.id; // Use unique ID for dragging

        if (index === currentTrackIndex) {
          li.classList.add('active');
        }

        li.innerHTML = `
          <img src="${track.coverArt || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodGgxMDAiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI2EwYTBhMCI+PHBhdGggZD0ibTEyIDJDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTAgMTZjLTMuMzEgMC02LTIuNjktNi02czIuNjktNiA2LTYgNiAyLjY5IDYgNi0yLjY5IDYtNiA2em0wLTguNWMtMS45MyAwLTMuNSAxLjU3LTMuNSAzLjVzMS41NyAzLjUgMy41IDMuNSAzLjUtMS41NyAzLjUtMy41LTEuNTctMy41LTMuNS0zLjV6Ii8+PC9zdmc+'}" alt="Cover Art">
          <div class="title-artist">
            <div class="title">${track.title}</div>
            <div class="artist">${track.artist || 'Unknown Artist'}</div>
          </div>
          <div class="playlist-item-controls">
            <button class="remove-from-playlist-btn" data-id="${track.id}" aria-label="Remove from playlist">✖</button>
            ${track.file && track.file instanceof File ? `<button class="download-btn" data-id="${track.id}" aria-label="Download track">⬇️</button>` : ''}
            <button class="edit-info-btn" data-id="${track.id}" aria-label="Edit track info">✏️</button>
          </div>
        `;
        playlistUl.appendChild(li);

        // Add event listener to play when clicking the item (excluding buttons)
        li.addEventListener('click', (event) => {
            if (!event.target.closest('button')) {
                currentTrackIndex = index;
                playCurrentTrack();
            }
        });
      });

      // Add event listeners for new buttons
      playlistUl.querySelectorAll('.remove-from-playlist-btn').forEach(button => {
          button.addEventListener('click', (event) => {
              event.stopPropagation(); // Prevent playlist item click
              const idToRemove = parseInt(event.target.dataset.id);
              removeTrackFromPlaylist(idToRemove);
          });
      });

      playlistUl.querySelectorAll('.download-btn').forEach(button => {
        button.addEventListener('click', (event) => {
          event.stopPropagation();
          const trackId = parseInt(event.target.dataset.id);
          const track = playlist.find(t => t.id === trackId);
          if (track && track.file instanceof File) {
            downloadFile(track.file, track.title);
          } else if (track && track.src && track.src.startsWith('blob:')) {
            // For blob URLs created from fetched data, we might need to re-fetch or reconstruct
            console.warn("Direct download of blob URLs not supported without original file. Implement re-fetching if needed.");
            alert("Cannot directly download streamed content. Only local files can be downloaded.");
          } else {
            alert("This track cannot be downloaded.");
          }
        });
      });

      playlistUl.querySelectorAll('.edit-info-btn').forEach(button => {
        button.addEventListener('click', (event) => {
          event.stopPropagation();
          const trackId = parseInt(event.target.dataset.id);
          const track = playlist.find(t => t.id === trackId);
          if (track) {
            editTrackInfo(track);
          }
        });
      });

      addDragDropListeners();
      // Ensure "no playlist message" is hidden if there are songs
      const noPlaylistMessage = document.getElementById('no-playlist-message');
      if (noPlaylistMessage) {
        noPlaylistMessage.style.display = playlist.length === 0 ? 'block' : 'none';
      }
    }

    function renderLibraryList(filterType = 'all', filterValue = null) {
      libraryListUl.innerHTML = '';
      let filteredItems = [];

      // Create unique lists for Albums, Artists, Genres
      if (filterType === 'all') {
        filteredItems = library.map(track => ({
          name: track.title,
          subInfo: track.artist,
          type: 'track',
          id: track.id
        }));
      } else if (filterType === 'albums') {
        const albumsMap = new Map();
        library.forEach(track => {
          const album = track.album || 'Unknown Album';
          if (!albumsMap.has(album)) {
            albumsMap.set(album, { name: album, count: 0, type: 'album' });
          }
          albumsMap.get(album).count++;
        });
        filteredItems = Array.from(albumsMap.values()).sort((a, b) => a.name.localeCompare(b.name));
      } else if (filterType === 'artists') {
        const artistsMap = new Map();
        library.forEach(track => {
          const artist = track.artist || 'Unknown Artist';
          if (!artistsMap.has(artist)) {
            artistsMap.set(artist, { name: artist, count: 0, type: 'artist' });
          }
          artistsMap.get(artist).count++;
        });
        filteredItems = Array.from(artistsMap.values()).sort((a, b) => a.name.localeCompare(b.name));
      } else if (filterType === 'genres') {
        const genresMap = new Map();
        library.forEach(track => {
          const genre = track.genre || 'Unknown Genre';
          if (!genresMap.has(genre)) {
            genresMap.set(genre, { name: genre, count: 0, type: 'genre' });
          }
          genresMap.get(genre).count++;
        });
        filteredItems = Array.from(genresMap.values()).sort((a, b) => a.name.localeCompare(b.name));
      } else if (filterType === 'filtered' && filterValue) {
          // This is for displaying songs under a specific album/artist/genre after clicking on them
          filteredItems = library.filter(track => {
              if (currentFilter.type === 'album') return (track.album || 'Unknown Album') === currentFilter.value;
              if (currentFilter.type === 'artist') return (track.artist || 'Unknown Artist') === currentFilter.value;
              if (currentFilter.type === 'genre') return (track.genre || 'Unknown Genre') === currentFilter.value;
              return false;
          }).map(track => ({
            name: track.title,
            subInfo: track.artist,
            type: 'track',
            id: track.id
          }));
      }

      if (filteredItems.length === 0) {
        const noItemsMessage = document.createElement('li');
        noItemsMessage.className = 'no-songs-message';
        noItemsMessage.textContent = 'No items found.';
        libraryListUl.appendChild(noItemsMessage);
        return;
      }

      filteredItems.forEach(item => {
        const li = document.createElement('li');
        li.className = 'library-list-item';
        li.dataset.type = item.type;
        li.dataset.value = item.name;
        if (item.id) li.dataset.id = item.id; // For individual tracks

        li.innerHTML = `
          <span>${item.name}</span>
          ${item.subInfo ? `<span> - ${item.subInfo}</span>` : ''}
          ${item.count ? `<span class="count">(${item.count})</span>` : ''}
        `;
        libraryListUl.appendChild(li);

        li.addEventListener('click', () => {
          if (item.type === 'track') {
            // Add individual track to playlist and play
            const trackToAdd = library.find(t => t.id === item.id);
            if (trackToAdd) {
              const existingIndex = playlist.findIndex(p => p.id === trackToAdd.id);
              if (existingIndex === -1) { // Only add if not already in playlist
                playlist.push(trackToAdd);
              }
              currentTrackIndex = playlist.findIndex(p => p.id === trackToAdd.id); // Set index to the added track
              playCurrentTrack();
              showTab('playlist-tab'); // Switch to playlist tab
            }
          } else {
            // Filter by album/artist/genre
            currentFilter.type = item.type;
            currentFilter.value = item.name;
            updateActiveFilterDisplay();
            renderLibraryList('filtered');
          }
        });
      });
    }

    function updateActiveFilterDisplay() {
        if (currentFilter.type !== 'all' && currentFilter.value) {
            currentFilterText.textContent = `Filtered by ${currentFilter.type}: ${currentFilter.value}`;
            activeFilterDisplay.classList.add('active');
        } else {
            activeFilterText.textContent = '';
            activeFilterDisplay.classList.remove('active');
        }
        // Deactivate all filter buttons, then activate the current one if applicable
        document.querySelectorAll('#library-filter-nav button').forEach(btn => btn.classList.remove('active'));
        if (currentFilter.type === 'all') {
            viewAllSongsBtn.classList.add('active');
        } else if (currentFilter.type === 'album') {
            viewAlbumsBtn.classList.add('active');
        } else if (currentFilter.type === 'artist') {
            viewArtistsBtn.classList.add('active');
        } else if (currentFilter.type === 'genre') {
            viewGenresBtn.classList.add('active');
        }
    }

    function clearFilter() {
        currentFilter = { type: 'all', value: null };
        updateActiveFilterDisplay();
        renderLibraryList('all'); // Re-render library with all songs
    }

    function removeTrackFromPlaylist(idToRemove) {
      const initialLength = playlist.length;
      playlist = playlist.filter(track => track.id !== idToRemove);

      // Adjust currentTrackIndex if the removed song was before or was the current one
      if (initialLength > playlist.length) { // If a song was actually removed
        if (idToRemove === playlist[currentTrackIndex]?.id) { // If current song was removed
            currentTrackIndex = -1; // Reset or decide next action
            audio.pause();
            updatePlayerInfo('No track playing', '');
            coverArt.src = '';
            playPauseBtn.textContent = '▶️';
            audio.src = '';
        } else if (currentTrackIndex > 0 && playlist[currentTrackIndex]?.id === undefined) {
             currentTrackIndex = Math.max(0, currentTrackIndex - 1);
        }
      }
      renderPlaylist();
    }


    // --- File Handling & ID3 Tag Reading ---
    async function handleFileSelection(event) {
        showLoadingIndicator('Adding music...');
        const files = Array.from(event.target.files);
        for (const file of files) {
            if (file.type.startsWith('audio/')) {
                const existingTrack = library.find(track => track.fileName === file.name && track.fileSize === file.size);
                if (existingTrack) {
                    console.log(`Skipping duplicate file: ${file.name}`);
                    continue;
                }
                const track = await parseAudioFile(file);
                if (track) {
                    const addedTrack = await addTrackToIndexedDB(track);
                    library.push(addedTrack);
                    playlist.push(addedTrack); // Add to playlist as well
                }
            } else {
                console.warn(`Skipping non-audio file: ${file.name}`);
            }
        }
        renderLibraryList('all');
        renderPlaylist();
        hideLoadingIndicator();
    }

    function parseAudioFile(file) {
      return new Promise((resolve) => {
        const jsmediatags = window.jsmediatags; // jsmediatags is globally available
        jsmediatags.read(file, {
          onSuccess: function(tag) {
            let title = tag.tags.title || file.name.split('.').slice(0, -1).join('.');
            let artist = tag.tags.artist || 'Unknown Artist';
            let album = tag.tags.album || 'Unknown Album';
            let genre = tag.tags.genre || 'Unknown Genre';
            let coverArt = '';

            if (tag.tags.picture) {
              const { data, format } = tag.tags.picture;
              let base64String = "";
              for (let i = 0; i < data.length; i++) {
                base64String += String.fromCharCode(data[i]);
              }
              coverArt = `data:${format};base64,${btoa(base64String)}`;
            }

            // Create a custom object to store in IndexedDB
            const track = {
              title: title,
              artist: artist,
              album: album,
              genre: genre,
              coverArt: coverArt,
              fileName: file.name,
              fileType: file.type,
              fileSize: file.size,
              lastModified: file.lastModified,
              file: file, // Store the actual File object
              src: null // Will be populated with URL.createObjectURL if needed for non-IndexedDB files
            };
            resolve(track);
          },
          onError: function(error) {
            console.error("Error reading ID3 tags:", error.type, error.info);
            // Even if tags can't be read, add the file with default info
            const track = {
              title: file.name.split('.').slice(0, -1).join('.'),
              artist: 'Unknown Artist',
              album: 'Unknown Album',
              genre: 'Unknown Genre',
              coverArt: '', // No cover art
              fileName: file.name,
              fileType: file.type,
              fileSize: file.size,
              lastModified: file.lastModified,
              file: file, // Store the actual File object
              src: null
            };
            resolve(track);
          }
        });
      });
    }

    function downloadFile(file, filename) {
        const url = URL.createObjectURL(file);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url); // Clean up the URL
    }

    function editTrackInfo(track) {
        const newTitle = prompt('Edit Title:', track.title);
        const newArtist = prompt('Edit Artist:', track.artist);
        const newAlbum = prompt('Edit Album:', track.album);
        const newGenre = prompt('Edit Genre:', track.genre);

        if (newTitle !== null && newArtist !== null && newAlbum !== null && newGenre !== null) {
            track.title = newTitle;
            track.artist = newArtist;
            track.album = newAlbum;
            track.genre = newGenre;
            updateTrackInIndexedDB(track).then(() => {
                renderPlaylist();
                renderLibraryList('all');
                if (currentTrackIndex !== -1 && playlist[currentTrackIndex]?.id === track.id) {
                    updatePlayerInfo(track.title, track.artist);
                }
            }).catch(e => console.error("Error updating track info:", e));
        }
    }


    // --- Stream Music ---
    function handleStreamMusic() {
      const url = streamUrlInput.value.trim();
      if (url) {
        // Simple validation, more robust validation needed for production
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
            alert('Please enter a valid URL (http:// or https://).');
            return;
        }
        // Check if it's likely an audio file
        const audioExtensions = ['.mp3', '.aac', '.ogg', '.wav', '.flac'];
        const isAudioFile = audioExtensions.some(ext => url.toLowerCase().endsWith(ext));

        if (!isAudioFile) {
            alert('The provided URL does not seem to be a direct link to an audio file (e.g., .mp3, .aac).');
            // Optionally, you could try to fetch and parse if it's a YouTube URL or similar
            // For now, only direct audio links are supported for streaming directly in <audio> tag.
            // For YouTube or other platforms, you would need a backend service to extract direct audio links.
            return;
        }

        const newStreamTrack = {
            id: Date.now(), // Use timestamp as a simple ID for streamed tracks
            title: url.substring(url.lastIndexOf('/') + 1) || 'Streamed Audio',
            artist: 'Streaming',
            album: 'Online Stream',
            genre: 'Stream',
            coverArt: '',
            src: url, // Store the URL directly
            file: null // No File object for streamed content
        };

        // Add to playlist and play
        playlist.push(newStreamTrack);
        currentTrackIndex = playlist.length - 1; // Set to the newly added track
        playCurrentTrack();
        showTab('playlist-tab'); // Switch to playlist tab
        streamUrlInput.value = ''; // Clear input
      } else {
        alert('Please enter a streaming URL.');
      }
    }


    // --- Playlist Drag and Drop ---
    let draggedItem = null;

    function addDragDropListeners() {
        const items = playlistUl.querySelectorAll('.playlist-item');
        items.forEach(item => {
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragover', handleDragOver);
            item.addEventListener('dragleave', handleDragLeave);
            item.addEventListener('drop', handleDrop);
            item.addEventListener('dragend', handleDragEnd);
        });
    }

    function handleDragStart(e) {
        draggedItem = this;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', this.innerHTML); // Required for Firefox
        this.classList.add('dragging');
    }

    function handleDragOver(e) {
        e.preventDefault(); // Necessary to allow drop
        e.dataTransfer.dropEffect = 'move';
        this.classList.add('drag-over-placeholder');
    }

    function handleDragLeave(e) {
        this.classList.remove('drag-over-placeholder');
    }

    function handleDrop(e) {
        e.preventDefault();
        this.classList.remove('drag-over-placeholder');

        if (draggedItem && draggedItem !== this) {
            const fromIndex = Array.from(playlistUl.children).indexOf(draggedItem);
            const toIndex = Array.from(playlistUl.children).indexOf(this);

            // Reorder the playlist array
            const [movedTrack] = playlist.splice(fromIndex, 1);
            playlist.splice(toIndex, 0, movedTrack);

            // Adjust currentTrackIndex if needed
            if (currentTrackIndex === fromIndex) {
                currentTrackIndex = toIndex;
            } else if (currentTrackIndex >= Math.min(fromIndex, toIndex) &&
                       currentTrackIndex <= Math.max(fromIndex, toIndex)) {
                if (fromIndex < toIndex) { // Moved down
                    currentTrackIndex--;
                } else { // Moved up
                    currentTrackIndex++;
                }
            }

            renderPlaylist(); // Re-render the UI
        }
    }

    function handleDragEnd(e) {
        this.classList.remove('dragging');
        playlistUl.querySelectorAll('.drag-over-placeholder').forEach(item => {
            item.classList.remove('drag-over-placeholder');
        });
        draggedItem = null;
    }


    // --- Visualizer ---
    function setupVisualizer() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256; // Fast Fourier Transform size
      }
      connectSourceToVisualizer();
    }

    function connectSourceToVisualizer() {
        if (!audioContext || !analyser) {
            console.warn("AudioContext or Analyser not initialized for visualizer.");
            return;
        }

        // Disconnect existing source if any
        if (sourceNode) {
            sourceNode.disconnect();
        }

        // Create a new MediaElementAudioSourceNode only if audio.src is available
        if (audio.src) {
            sourceNode = audioContext.createMediaElementSource(audio);
            sourceNode.connect(analyser);
            analyser.connect(audioContext.destination); // Connect analyser to speakers
        } else {
            console.log("Audio source not available for visualizer connection.");
        }
        drawVisualizer(); // Start drawing even if no source connected yet (will show flat line)
    }

    function drawVisualizer() {
      const canvasCtx = visualizerCanvas.getContext('2d');
      const WIDTH = visualizerCanvas.width;
      const HEIGHT = visualizerCanvas.height;

      animationFrameId = requestAnimationFrame(drawVisualizer);

      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      analyser.getByteFrequencyData(dataArray);

      canvasCtx.clearRect(0, 0, WIDTH, HEIGHT); // Clear the canvas

      const barWidth = (WIDTH / bufferLength) * 2.5;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        const barHeight = dataArray[i] / 2; // Scale height for visualization

        canvasCtx.fillStyle = `rgb(${barHeight + 100},${50},${varConverter.primaryColorRgb[2]})`; // Dynamic color
        canvasCtx.fillRect(x, HEIGHT - barHeight, barWidth, barHeight);

        x += barWidth + 1; // Space between bars
      }
    }

    // --- Search and Filter ---
    function filterPlaylist() {
      const searchTerm = searchInput.value.toLowerCase();
      if (!searchTerm) {
        playlist = [...library]; // Reset playlist to full library if search is empty
      } else {
        playlist = library.filter(track =>
          (track.title && track.title.toLowerCase().includes(searchTerm)) ||
          (track.artist && track.artist.toLowerCase().includes(searchTerm)) ||
          (track.album && track.album.toLowerCase().includes(searchTerm)) ||
          (track.genre && track.genre.toLowerCase().includes(searchTerm))
        );
      }
      renderPlaylist();
      // If a song is currently playing and it's no longer in the filtered playlist, pause it.
      if (currentTrackIndex !== -1 && !playlist.includes(library.find(t => t.id === playlist[currentTrackIndex]?.id))) {
          audio.pause();
          playPauseBtn.textContent = '▶️';
          currentTrackIndex = -1;
          updatePlayerInfo('No track playing', '');
          coverArt.src = '';
      }
    }

    // --- Settings ---
    const varConverter = {
        primaryColorRgb: [255, 111, 97], // Default
        update: function(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            this.primaryColorRgb = [r, g, b];
        }
    };

    function applyThemeColor(color) {
      document.documentElement.style.setProperty('--primary-color', color);
      varConverter.update(color); // Update converter with new RGB
      document.documentElement.style.setProperty('--primary-color-rgb', varConverter.primaryColorRgb.join(', '));
      saveSetting('themeColor', color);
    }

    async function loadSettings() {
        const savedLang = await loadSetting('language');
        if (savedLang) {
            langSelect.value = savedLang;
            // You would also load translation files here based on savedLang
        }
        const savedColor = await loadSetting('themeColor');
        if (savedColor) {
            themeColorPicker.value = savedColor;
            applyThemeColor(savedColor);
        }
        const savedShuffle = await loadSetting('isShuffling');
        if (savedShuffle !== null) {
            isShuffling = savedShuffle;
            shuffleBtn.classList.toggle('active', isShuffling);
            shuffleBtn.setAttribute('aria-pressed', isShuffling);
        }
        const savedRepeat = await loadSetting('repeatMode');
        if (savedRepeat) {
            repeatMode = savedRepeat;
            toggleRepeat(); // Call to update icon and title based on loaded mode
            toggleRepeat(); // Call again to cycle to correct state as first call increments
        }
    }


    // --- Preload All Music (for offline) ---
    async function preloadAllMusic() {
        showLoadingIndicator('Preloading all music...');
        const preloadPromises = library.map(async track => {
            if (track.file instanceof File) {
                // For files already in memory, simply create an object URL
                // The service worker would cache these on fetch
                const url = URL.createObjectURL(track.file);
                // We don't actually need to "fetch" it here, just make sure the SW can intercept it
                // A simple fetch of the URL can trigger SW caching if configured.
                try {
                    await fetch(url, { cache: 'force-cache' }); // Attempt to force cache via SW
                    console.log(`Preloaded: ${track.title}`);
                } catch (error) {
                    console.warn(`Failed to preload ${track.title}:`, error);
                } finally {
                    URL.revokeObjectURL(url); // Clean up
                }
            } else if (track.src) {
                // For streamed content (URLs), fetch and let service worker cache it
                try {
                    await fetch(track.src, { cache: 'force-cache' });
                    console.log(`Preloaded streamed track: ${track.title}`);
                } catch (error) {
                    console.warn(`Failed to preload streamed track ${track.title}:`, error);
                }
            }
        });
        await Promise.allSettled(preloadPromises); // Wait for all preloads to attempt
        alert('Preloading complete! Check console for details.');
        hideLoadingIndicator();
    }


    // --- Playlist Export/Import ---
    function exportPlaylist() {
        const playlistData = playlist.map(track => ({
            title: track.title,
            artist: track.artist,
            album: track.album,
            genre: track.genre,
            coverArt: track.coverArt,
            fileName: track.fileName,
            fileType: track.fileType,
            fileSize: track.fileSize,
            lastModified: track.lastModified,
            src: track.src // Include src for streamed tracks
            // Note: actual File objects cannot be directly serialized to JSON.
            // For true import, you'd need to re-add local files or handle URLs.
        }));
        const jsonString = JSON.stringify(playlistData, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'playlist.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        alert('Playlist exported as playlist.json');
    }

    async function importPlaylist(event) {
        const file = event.target.files[0];
        if (!file) return;

        showLoadingIndicator('Importing playlist...');
        try {
            const text = await file.text();
            const importedPlaylist = JSON.parse(text);

            for (const trackData of importedPlaylist) {
                // If it's a local file entry, we can't restore the File object directly.
                // User would need to re-add them.
                // For simplicity, we'll only import tracks with 'src' (streamed/blob URLs)
                // or create placeholder entries for local files.
                if (trackData.src) {
                    const newTrack = {
                        id: Date.now() + Math.random(), // Unique ID
                        title: trackData.title,
                        artist: trackData.artist,
                        album: trackData.album,
                        genre: trackData.genre,
                        coverArt: trackData.coverArt,
                        src: trackData.src,
                        file: null
                    };
                    playlist.push(newTrack);
                    // Add to library as well if it's a new unique track
                    if (!library.some(t => t.src === newTrack.src)) {
                        library.push(newTrack);
                    }
                } else {
                    // For local files, create a placeholder. User will need to manually re-add them.
                    const placeholderTrack = {
                        id: Date.now() + Math.random(),
                        title: trackData.title + " (Missing File)",
                        artist: trackData.artist,
                        album: trackData.album,
                        genre: trackData.genre,
                        coverArt: trackData.coverArt,
                        src: null,
                        file: null // The actual file is not imported
                    };
                    playlist.push(placeholderTrack);
                    library.push(placeholderTrack); // Add to library too
                }
            }
            renderPlaylist();
            renderLibraryList('all');
            alert('Playlist imported successfully! Note: Local files need to be re-added.');
        } catch (error) {
            console.error('Error importing playlist:', error);
            alert('Failed to import playlist. Make sure it\'s a valid JSON file.');
        } finally {
            hideLoadingIndicator();
        }
    }


    // --- Event Listeners ---
    function initEventListeners() {
      // Audio Events
      audio.addEventListener('timeupdate', () => {
        const progress = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${progress}%`;

        document.getElementById('current-time').textContent = formatTime(audio.currentTime);
        document.getElementById('total-time').textContent = formatTime(audio.duration);
      });

      audio.addEventListener('ended', () => {
        if (repeatMode === 'one') {
          playCurrentTrack(); // Repeat current track
        } else if (repeatMode === 'all') {
          playNextTrack(); // Play next in loop
        } else { // No repeat, or 'none' mode
          playNextTrack(); // Move to next track
        }
      });

      audio.addEventListener('error', (e) => {
        console.error('Audio error:', e);
        alert('An error occurred during audio playback. This might be due to unsupported format, network issues, or a corrupt file. Moving to next track.');
        playNextTrack();
      });

      // Player Controls
      playPauseBtn.addEventListener('click', togglePlayPause);
      prevBtn.addEventListener('click', playPrevTrack);
      nextBtn.addEventListener('click', playNextTrack);
      shuffleBtn.addEventListener('click', toggleShuffle);
      repeatBtn.addEventListener('click', toggleRepeat);

      progressBarContainer.addEventListener('click', (e) => {
        const clickX = e.clientX - progressBarContainer.getBoundingClientRect().left;
        const width = progressBarContainer.getBoundingClientRect().width;
        audio.currentTime = (clickX / width) * audio.duration;
      });

      document.getElementById('volume-slider').addEventListener('input', (e) => {
        audio.volume = e.target.value;
      });

      playbackSpeedSelect.addEventListener('change', (e) => {
          audio.playbackRate = parseFloat(e.target.value);
          saveSetting('playbackSpeed', e.target.value);
      });

      // Tab Navigation
      libraryTabBtn.addEventListener('click', () => showTab('library-tab-content'));
      playlistTabBtn.addEventListener('click', () => showTab('playlist-tab-content'));

      // File & Stream Input
      addMusicBtn.addEventListener('click', () => addMusicFileInput.click());
      addMusicFileInput.addEventListener('change', handleFileSelection);
      playStreamBtn.addEventListener('click', handleStreamMusic);

      // Search
      searchInput.addEventListener('input', filterPlaylist);

      // Library Filters
      viewAllSongsBtn.addEventListener('click', clearFilter);
      viewAlbumsBtn.addEventListener('click', () => { currentFilter = { type: 'albums', value: null }; updateActiveFilterDisplay(); renderLibraryList('albums'); });
      viewArtistsBtn.addEventListener('click', () => { currentFilter = { type: 'artists', value: null }; updateActiveFilterDisplay(); renderLibraryList('artists'); });
      viewGenresBtn.addEventListener('click', () => { currentFilter = { type: 'genres', value: null }; updateActiveFilterDisplay(); renderLibraryList('genres'); });
      clearFilterBtn.addEventListener('click', clearFilter);

      // Settings
      langSelect.addEventListener('change', (e) => saveSetting('language', e.target.value));
      themeColorPicker.addEventListener('input', (e) => applyThemeColor(e.target.value));

      // Tools
      preloadAllBtn.addEventListener('click', preloadAllMusic);
      mp3ConverterBtn.addEventListener('click', () => alert('MP3 Converter functionality to be implemented.')); // Placeholder

      // Export/Import Playlist
      exportPlaylistBtn.addEventListener('click', exportPlaylist);
      importPlaylistBtn.addEventListener('click', () => importFileInput.click());
      importFileInput.addEventListener('change', importPlaylist);

      // Drag and Drop (outside player container for adding files)
      playerContainer.addEventListener('dragover', (e) => {
          e.preventDefault();
          playerContainer.classList.add('dragover');
      });

      playerContainer.addEventListener('dragleave', (e) => {
          e.preventDefault();
          if (!playerContainer.contains(e.relatedTarget)) { // Only remove if leaving the entire container
              playerContainer.classList.remove('dragover');
          }
      });

      playerContainer.addEventListener('drop', async (e) => {
          e.preventDefault();
          playerContainer.classList.remove('dragover');
          showLoadingIndicator('Adding files...');

          const files = Array.from(e.dataTransfer.files);
          for (const file of files) {
              if (file.type.startsWith('audio/')) {
                  const existingTrack = library.find(track => track.fileName === file.name && track.fileSize === file.size);
                  if (existingTrack) {
                      console.log(`Skipping duplicate file: ${file.name}`);
                      continue;
                  }
                  const track = await parseAudioFile(file);
                  if (track) {
                      const addedTrack = await addTrackToIndexedDB(track);
                      library.push(addedTrack);
                      playlist.push(addedTrack); // Add to playlist as well
                  }
              } else {
                  console.warn(`Skipping non-audio file: ${file.name}`);
              }
          }
          renderLibraryList('all');
          renderPlaylist();
          hideLoadingIndicator();
      });
    }

    // --- Tab Switching Logic ---
    function showTab(tabId) {
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.style.display = 'none';
        tab.classList.remove('active');
      });
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
        btn.setAttribute('aria-selected', 'false');
        btn.setAttribute('tabindex', '-1');
      });

      const activeTabContent = document.getElementById(tabId);
      const activeTabBtn = document.getElementById(tabId.replace('-content', '-btn'));

      if (activeTabContent && activeTabBtn) {
        activeTabContent.style.display = 'flex'; // Use flex for column layout
        activeTabContent.classList.add('active');
        activeTabBtn.classList.add('active');
        activeTabBtn.setAttribute('aria-selected', 'true');
        activeTabBtn.setAttribute('tabindex', '0');
      }
    }


    // --- Initialization ---
    async function init() {
      showLoadingIndicator('Initializing player...');
      await openIndexedDB();
      await loadTracksFromIndexedDB(); // Load existing tracks from IndexedDB
      await loadSettings(); // Load user settings

      // Set initial active tab
      showTab('playlist-tab-content'); // Default to showing the playlist tab

      initEventListeners();

      if (playlist.length > 0) {
        currentTrackIndex = 0; // Start with the first track
        // Do not autoplay, just set info
        updatePlayerInfo(playlist[currentTrackIndex].title, playlist[currentTrackIndex].artist);
        updateCoverArt(playlist[currentTrackIndex].coverArt);
      } else {
        updatePlayerInfo('No track playing', ''); // Set "No track playing" if playlist is empty
      }
      renderPlaylist(); // Ensure playlist is rendered initially
      renderLibraryList('all'); // Render library list with 'all' songs view initially

      setupVisualizer();
      hideLoadingIndicator();
    }

    init();

    // Service Worker Registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered with scope:', registration.scope);
          })
          .catch((error) => {
            console.error('Service Worker registration failed:', error);
          });
      });
    }

  })();
</script>
<script src="https://unpkg.com/jsmediatags@3.9.5/dist/jsmediatags.min.js"></script>
</body>
</html>
