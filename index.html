<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Music Player</title>

<link rel="manifest" href="/manifest.json">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Music Player">
<link rel="apple-touch-icon" href="/icons/icon-192x192.png">

<style>
  /* Reset */
  * {
    box-sizing: border-box;
  }

  :root {
    --primary-color: #ff6f61; /* Define a CSS variable for the primary color */
    --background-dark: #121212;
    --background-medium: #1e1e1e;
    --background-light: #272727;
    --text-color: #eee;
    --text-muted: #aaa;
    --border-color: #2a2a2a;
    --shadow-color: rgba(0, 0, 0, 0.6);
  }

  body {
    margin: 0;
    background-color: var(--background-dark);
    color: var(--text-color);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center; /* Center vertically */
    padding: 20px;
    min-height: 100vh;
    overflow-y: auto; /* Allow scrolling if content is taller than viewport */
  }

  #player-container {
    background: var(--background-medium);
    width: 360px;
    max-width: 100%; /* Ensure responsiveness on smaller screens */
    border-radius: 16px;
    box-shadow: 0 10px 30px var(--shadow-color); /* Enhanced shadow */
    overflow: hidden;
    display: flex;
    flex-direction: column;
    user-select: none;
    margin: auto; /* Center horizontally if max-width is hit */
  }

  /* Section Grouping Styles */
  .section-group {
    padding: 15px 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    border-top: 1px solid var(--border-color);
  }

  .section-group:first-of-type {
    border-top: none;
  }

  .section-group h3 {
    margin: 0;
    color: var(--primary-color);
    font-size: 1.1em; /* Slightly larger heading */
    text-transform: uppercase;
    letter-spacing: 0.8px; /* More prominent spacing */
    padding-bottom: 5px; /* Space below heading */
  }

  /* Cover Art & Controls */
  #player-header {
    position: relative; /* For current song info overlay */
    background: var(--background-medium);
  }

  #cover-art {
    width: 100%;
    aspect-ratio: 1/1;
    object-fit: cover;
    display: block; /* Remove extra space below image */
    box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.8); /* Darker inner shadow */
    background: #2a2a2a;
  }

  #current-song-info {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
    padding: 20px 20px 10px 20px; /* More padding at bottom */
    color: #fff;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    opacity: 0; /* Hidden by default */
    transition: opacity 0.3s ease-in-out;
  }

  #player-header:hover #current-song-info {
    opacity: 1; /* Show on hover */
  }

  #current-song-info .title {
    font-size: 1.2em; /* Larger title */
    font-weight: 700;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  #current-song-info .artist {
    font-size: 0.9em;
    color: #ccc;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  #playback-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 14px;
    padding: 15px 20px;
    background: var(--background-light); /* Slightly lighter for controls */
    border-top: 1px solid var(--border-color);
    position: relative; /* For progress bar positioning */
  }

  #progress-bar-container {
    position: absolute;
    top: 0; /* Position at the very top of the controls div */
    left: 0;
    width: 100%;
    height: 6px; /* Slimmer progress bar */
    background-color: #383838;
    cursor: pointer;
    border-radius: 3px 3px 0 0; /* Rounded top corners */
  }

  #progress-bar {
    height: 100%;
    width: 0%;
    background-color: var(--primary-color);
    border-radius: 3px 3px 0 0;
    transition: width 0.1s linear; /* Smoother progress animation */
  }

  #playback-controls button {
    background: #333;
    border: none;
    border-radius: 50%;
    width: 42px;
    height: 42px;
    color: var(--text-color);
    font-size: 18px;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease; /* Add transform transition */
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3); /* Subtle button shadow */
  }

  #playback-controls button:hover,
  #playback-controls button:focus {
    background-color: var(--primary-color);
    outline: none;
    transform: translateY(-2px); /* Slight lift on hover */
  }

  #play-pause-btn {
    width: 54px;
    height: 54px;
    font-size: 22px;
    background: var(--primary-color);
    box-shadow: 0 0 12px var(--primary-color)aa; /* More pronounced glow */
  }

  #play-pause-btn:hover,
  #play-pause-btn:focus {
    background: #ff4b3f;
    box-shadow: 0 0 16px #ff4b3fcc;
    transform: scale(1.05); /* Slightly larger on hover */
  }

  /* Main Features Section (Search & Playlist) */
  #main-features {
    background: var(--background-dark);
    padding-top: 15px;
    padding-bottom: 0;
  }

  #search-input {
    width: calc(100% - 40px);
    margin: 0 20px 15px 20px;
    padding: 10px 15px; /* More padding */
    border-radius: 10px; /* Slightly more rounded */
    border: none;
    font-size: 15px; /* Slightly larger font */
    background-color: var(--background-light);
    color: var(--text-color);
    outline: none;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
  }

  #search-input::placeholder {
    color: #777;
  }

  #search-input:focus {
    background-color: #3c3c3c;
    box-shadow: 0 0 0 2px var(--primary-color); /* Focus ring */
  }

  #playlist {
    max-height: 280px;
    overflow-y: auto;
    background: var(--background-dark);
    padding: 8px 0;
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) #2a2a2a;
    border-top: 1px solid var(--border-color);
    list-style: none; /* Remove default list bullets */
  }

  #playlist::-webkit-scrollbar {
    width: 8px;
  }

  #playlist::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 4px;
  }

  .playlist-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 20px;
    cursor: pointer;
    transition: background-color 0.25s ease, transform 0.1s ease;
    border-left: 4px solid transparent;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    user-select:none;
    position: relative;
    padding-right: 120px; /* Make space for the new controls */
  }

  .playlist-item:hover {
    background-color: #272727;
    transform: translateX(3px); /* Subtle slide on hover */
  }

  .playlist-item.active {
    background-color: rgba(var(--primary-color-rgb), 0.2); /* Semi-transparent primary */
    border-left-color: var(--primary-color);
    color: var(--text-color);
  }
  
  /* Calculate RGB for active state if needed, or use a fixed rgba */
  /* This needs JS to set a --primary-color-rgb variable */


  .playlist-item img {
    width: 40px; /* Slightly larger image */
    height: 40px;
    object-fit: cover;
    border-radius: 8px; /* More rounded corners */
    box-shadow: 0 2px 8px rgba(0,0,0,0.4); /* Enhanced image shadow */
    flex-shrink: 0;
  }

  .title-artist {
    display: flex;
    flex-direction: column;
    font-size: 14px;
    overflow: hidden;
    flex-grow: 1; /* Allow title/artist to take available space */
  }

  .title-artist .title {
    font-weight: 600;
    color: #fff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .title-artist .artist {
    font-weight: 400;
    color: var(--text-muted); /* Use muted text color */
    font-size: 12px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Download/Delete buttons */
  .download-btn,
  .delete-download-btn {
    margin-left: auto;
    background: none;
    border: none;
    color: var(--text-muted); /* Muted color */
    font-size: 1.2em;
    cursor: pointer;
    opacity: 0.7; /* Slightly less opaque */
    transition: opacity 0.2s ease, transform 0.2s ease;
    padding: 5px;
    border-radius: 4px;
    flex-shrink: 0; /* Prevent shrinking */
  }

  .download-btn:hover,
  .download-btn:focus,
  .delete-download-btn:hover,
  .delete-download-btn:focus {
    opacity: 1;
    background-color: rgba(255, 255, 255, 0.15); /* Slightly brighter hover */
    outline: none;
    transform: scale(1.1); /* Pop out slightly */
  }

  .delete-download-btn {
    color: #ff4b3f; /* Red for delete */
  }

  .download-btn:disabled,
  .delete-download-btn:disabled {
    cursor: not-allowed;
    opacity: 0.3; /* More faded when disabled */
    transform: none; /* No transform when disabled */
  }

  /* NEW: Playlist management buttons */
  .playlist-item-controls {
      display: flex;
      gap: 5px;
      align-items: center;
      margin-left: 10px; /* Small margin to separate from download/delete */
      flex-shrink: 0; /* Prevent shrinking */
  }

  .playlist-item-controls button {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1em;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s ease, transform 0.2s ease;
      padding: 5px;
      border-radius: 4px;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 30px;
      height: 30px;
  }

  .playlist-item-controls button:hover {
      opacity: 1;
      background-color: rgba(255, 255, 255, 0.15);
      transform: scale(1.05);
  }

  .playlist-item-controls .remove-from-playlist-btn {
      color: #ff6f61;
  }

  .playlist-item-controls .remove-from-playlist-btn:hover {
      background-color: rgba(255, 111, 97, 0.25);
  }

  .playlist-item-controls button:disabled {
    cursor: not-allowed;
    opacity: 0.3;
    transform: none;
  }


  /* Action Buttons & Inputs (General Styling) */
  .section-group input[type="url"],
  .section-group button {
    width: 100%;
    padding: 10px;
    border: none;
    border-radius: 10px;
    background-color: var(--primary-color);
    color: white;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3); /* Button shadows */
  }

  .section-group input[type="url"] {
    background-color: var(--background-light);
    color: var(--text-color);
    font-weight: normal;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3); /* Inset shadow for inputs */
  }

  .section-group input[type="url"]::placeholder {
    color: #777;
  }

  .section-group input[type="url"]:focus {
    background-color: #3c3c3c;
    box-shadow: 0 0 0 2px var(--primary-color), inset 0 1px 3px rgba(0,0,0,0.3);
  }

  .section-group button:hover,
  .section-group button:focus {
    background-color: #ff4433;
    outline: none;
    transform: translateY(-2px); /* Lift button on hover */
    box-shadow: 0 4px 10px rgba(0,0,0,0.4);
  }

  .section-group button:active {
    transform: translateY(0); /* Press effect */
    box-shadow: 0 1px 3px rgba(0,0,0,0.4);
  }

  /* Visualizer */
  #visualizer {
    width: 100%;
    height: 60px;
    background: #181818;
    border-top: 1px solid var(--border-color);
  }

  /* Settings Section */
  #settings-section {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
  }

  #lang-select,
  #theme-color-picker {
    flex-grow: 1;
    padding: 8px 12px; /* More padding */
    border-radius: 10px; /* More rounded */
    background: var(--background-light);
    border: none;
    color: var(--text-color);
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
  }

  #lang-select:hover,
  #lang-select:focus,
  #theme-color-picker:hover,
  #theme-color-picker:focus {
    background-color: #3c3c3c;
    outline: none;
    box-shadow: 0 0 0 2px var(--primary-color), inset 0 1px 3px rgba(0,0,0,0.3);
  }

  #theme-color-picker {
    width: 50px; /* Fixed width for color picker */
    height: 38px; /* Adjust height to match select */
    padding: 0;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    border: 1px solid var(--border-color); /* Add a border to picker */
    overflow: hidden; /* Hide default color input style */
  }

  #theme-color-picker::-webkit-color-swatch-wrapper {
      padding: 0;
  }
  #theme-color-picker::-webkit-color-swatch {
      border: none;
      border-radius: 8px; /* Match outer border radius */
  }
  #theme-color-picker::-moz-color-swatch,
  #theme-color-picker::-moz-focus-inner {
      border: none;
      border-radius: 8px;
  }


  /* Drag & Drop highlight */
  #player-container.dragover {
    border: 3px dashed var(--primary-color);
    box-shadow: 0 0 20px rgba(var(--primary-color-rgb), 0.5); /* Glowing border */
  }

  /* Media Queries for Responsiveness */
  @media (max-width: 400px) {
    body {
      padding: 10px;
    }
    #player-container {
      border-radius: 0; /* Full width on very small screens */
      height: 100vh; /* Fill screen height on mobile */
      width: 100%;
    }
    .section-group {
      padding: 10px 15px;
    }
    #playback-controls {
      gap: 10px;
      padding: 10px 15px;
    }
    #playback-controls button {
      width: 38px;
      height: 38px;
      font-size: 16px;
    }
    #play-pause-btn {
      width: 48px;
      height: 48px;
      font-size: 20px;
    }
    #search-input {
      width: calc(100% - 30px);
      margin: 0 15px 10px 15px;
    }
    .playlist-item {
      padding: 8px 15px;
    }
    .playlist-item img {
      width: 32px;
      height: 32px;
    }
    .title-artist .title {
      font-size: 13px;
    }
    .title-artist .artist {
      font-size: 11px;
    }
    .download-btn, .delete-download-btn, .playlist-item-controls button {
        font-size: 1em;
        width: 28px;
        height: 28px;
    }
    #current-song-info .title {
      font-size: 1.1em;
    }
    #current-song-info .artist {
      font-size: 0.8em;
    }
  }

</style>
</head>
<body>
<div id="player-container" role="main" aria-label="Music Player" tabindex="0">

  <div id="player-header">
    <img id="cover-art" src="" alt="No track playing" />
    <div id="current-song-info">
      <div class="title" id="current-song-title"></div>
      <div class="artist" id="current-song-artist"></div>
    </div>
  </div>

  <div id="playback-controls" role="region" aria-label="Playback controls">
    <div id="progress-bar-container">
      <div id="progress-bar"></div>
    </div>
    <button id="prev-btn" aria-label="Previous track" tabindex="0">⏮</button>
    <button id="play-pause-btn" aria-label="Play/Pause" tabindex="0">▶️</button>
    <button id="next-btn" aria-label="Next track" tabindex="0">⏭</button>
    <button id="shuffle-btn" aria-pressed="false" aria-label="Shuffle toggle" tabindex="0">🔀</button>
    <button id="repeat-btn" aria-pressed="false" aria-label="Repeat toggle" tabindex="0">🔁</button>
  </div>

  <div id="main-features" class="section-group">
    <h3>Playlist</h3>
    <input id="search-input" type="search" placeholder="Search songs..." aria-label="Search songs" />
    <ul id="playlist" role="list" tabindex="0" aria-label="Playlist"></ul>
  </div>

  <div id="action-buttons-group">
    <div id="stream-section" class="section-group">
      <h3>Stream Music</h3>
      <input id="stream-url-input" type="url" placeholder="Enter streaming URL (mp3/aac)" aria-label="Streaming URL" />
      <button id="play-stream-btn" aria-label="Play stream from URL">Play Stream</button>
    </div>

    <div id="file-management-section" class="section-group">
      <h3>File Management</h3>
      <button id="add-music-btn" aria-label="Add songs from device">Add Songs from Device</button>
      <input type="file" id="add-music-file-input" accept="audio/*" multiple hidden />

      <button id="export-playlist-btn" aria-label="Export playlist">Export Playlist</button>
      <button id="import-playlist-btn" aria-label="Import playlist">Import Playlist</button>
      <input type="file" id="import-file-input" accept=".json" hidden />
    </div>

    <div id="tools-section" class="section-group">
      <h3>Tools</h3>
      <button id="preload-all-btn" aria-label="Preload all music">Preload All Music</button>
      <button id="mp3-converter-btn" aria-label="Go to MP3 Converter">Go to MP3 Converter</button>
    </div>
  </div>

  <canvas id="visualizer" aria-hidden="true"></canvas>

  <div id="settings-section" class="section-group">
    <h3>Settings</h3>
    <select id="lang-select" aria-label="Select language">
      <option value="en" selected>English</option>
      <option value="es">Español</option>
      <option value="fr">Français</option>
      <option value="de">Deutsch</option>
    </select>
    <input type="color" id="theme-color-picker" value="#ff6f61" aria-label="Choose theme color" />
  </div>

</div>

<script>
(() => {
  // Localization strings
  const locales = {
    en: {
      searchPlaceholder: "Search songs...",
      streamPlaceholder: "Enter streaming URL (mp3/aac)",
      playStream: "Play Stream",
      addMusic: "Add Songs from Device",
      exportPlaylist: "Export Playlist",
      importPlaylist: "Import Playlist",
      noTrack: "No track playing",
      shuffle: "Shuffle toggle",
      repeat: "Repeat toggle",
      prevTrack: "Previous track",
      nextTrack: "Next track",
      playPause: "Play/Pause",
      playlist: "Playlist",
      selectLang: "Select language",
      fileNotSupported: "File type not supported. Use mp3, wav, ogg, aac.",
      importError: "Failed to import playlist.",
      noSongsInPlaylist: "No songs in playlist.",
      errorLoadingFile: "Error loading file:",
      downloadTrack: "Download track",
      deleteDownloadedTrack: "Delete downloaded track",
      downloadedAlert: "downloaded!",
      downloadFailedAlert: "Failed to download music. See console for details.",
      deleteDownloadedAlert: "deleted from downloads.",
      deleteFailedAlert: "Failed to delete music. See console for details.",
      mp3Converter: "Go to MP3 Converter",
      preloadAllMusic: "Preload All Music",
      preloadingAll: "Preloading all...",
      preloading: "Preloading",
      preloadComplete: "Preload complete!",
      of: "of",
      tracks: "tracks",
      failedToPreload: "failed to preload",
      noSongsInPlaylistToPreload: "No songs in playlist to preload.",
      autoplayBlocked: "Autoplay blocked. Please tap play or select a song.",
      // New headings
      playlistHeading: "Playlist",
      streamMusicHeading: "Stream Music",
      fileManagementHeading: "File Management",
      toolsHeading: "Tools",
      settingsHeading: "Settings",
    },
    es: {
      searchPlaceholder: "Buscar canciones...",
      streamPlaceholder: "Introduce URL de streaming (mp3/aac)",
      playStream: "Reproducir Streaming",
      addMusic: "Añadir canciones del dispositivo",
      exportPlaylist: "Exportar Lista",
      importPlaylist: "Importar Lista",
      noTrack: "Ninguna canción reproducida",
      shuffle: "Alternar aleatorio",
      repeat: "Alternar repetición",
      prevTrack: "Pista anterior",
      nextTrack: "Siguiente pista",
      playPause: "Reproducir/Pausar",
      playlist: "Lista de reproducción",
      selectLang: "Seleccionar idioma",
      fileNotSupported: "Tipo de archivo no soportado. Usa mp3, wav, ogg, aac.",
      importError: "Error al importar la lista.",
      noSongsInPlaylist: "No hay canciones en la lista.",
      errorLoadingFile: "Error cargando archivo:",
      downloadTrack: "Descargar pista",
      deleteDownloadedTrack: "Eliminar pista descargada",
      downloadedAlert: "descargado!",
      downloadFailedAlert: "Fallo al descargar la música. Ver consola para detalles.",
      deleteDownloadedAlert: "eliminado de las descargas.",
      deleteFailedAlert: "Fallo al eliminar la música. Ver consola para detalles.",
      mp3Converter: "Ir al convertidor de MP3",
      preloadAllMusic: "Precargar toda la música",
      preloadingAll: "Precargando todo...",
      preloading: "Precargando",
      preloadComplete: "¡Precarga completa!",
      of: "de",
      tracks: "canciones",
      failedToPreload: "fallaron al precargar",
      noSongsInPlaylistToPreload: "No hay canciones en la lista para precargar.",
      autoplayBlocked: "Autoplay bloqueado. Toca reproducir o selecciona una canción.",

      // New headings
      playlistHeading: "Lista de Reproducción",
      streamMusicHeading: "Reproducir Música",
      fileManagementHeading: "Gestión de Archivos",
      toolsHeading: "Herramientas",
      settingsHeading: "Configuración",
    },
    fr: {
      searchPlaceholder: "Rechercher des chansons...",
      streamPlaceholder: "Entrez l'URL de streaming (mp3/aac)",
      playStream: "Lire le flux",
      addMusic: "Ajouter des chansons depuis l'appareil",
      exportPlaylist: "Exporter la liste",
      importPlaylist: "Importer la liste",
      noTrack: "Aucune piste en cours",
      shuffle: "Activer le mode aléatoire",
      repeat: "Activer la répétition",
      prevTrack: "Piste precedente",
      nextTrack: "Piste suivante",
      playPause: "Lecture/Pause",
      playlist: "Liste de lecture",
      selectLang: "Choisir la langue",
      fileNotSupported: "Type de fichier non pris en charge. Utilisez mp3, wav, ogg, aac.",
      importError: "Échec de l'importation de la liste.",
      noSongsInPlaylist: "Aucune chanson dans la liste.",
      errorLoadingFile: "Erreur de chargement du fichier :",
      downloadTrack: "Télécharger la piste",
      deleteDownloadedTrack: "Supprimer la piste téléchargée",
      downloadedAlert: "téléchargé !",
      downloadFailedAlert: "Échec du téléchargement de la musique. Voir la console pour plus de détails.",
      deleteDownloadedAlert: "supprimé des téléchargements.",
      deleteFailedAlert: "Échec de la suppression de la musique. Voir la console pour plus de détails.",
      mp3Converter: "Aller au convertisseur MP3",
      preloadAllMusic: "Précharger toute la musique",
      preloadingAll: "Préchargement en cours...",
      preloading: "Préchargement",
      preloadComplete: "Préchargement terminé !",
      of: "de",
      tracks: "pistes",
      failedToPreload: "n'ont pas pu être préchargées",
      noSongsInPlaylistToPreload: "Aucune chanson dans la playlist à précharger.",
      autoplayBlocked: "Autoplay bloqué. Veuillez appuyer sur lecture ou sélectionner une chanson.",

      // New headings
      playlistHeading: "Liste de lecture",
      streamMusicHeading: "Diffuser de la musique",
      fileManagementHeading: "Gestion des fichiers",
      toolsHeading: "Outils",
      settingsHeading: "Paramètres",
    },
    de: {
      searchPlaceholder: "Songs suchen...",
      streamPlaceholder: "Streaming-URL eingeben (mp3/aac)",
      playStream: "Stream abspielen",
      addMusic: "Songs vom Gerät hinzufügen",
      exportPlaylist: "Playlist exportieren",
      importPlaylist: "Playlist importieren",
      noTrack: "Kein Titel läuft",
      shuffle: "Shuffle ein-/ausschalten",
      repeat: "Wiederholung ein-/ausschalten",
      prevTrack: "Vorheriger Titel",
      nextTrack: "Nächster Titel",
      playPause: "Abspielen/Pause",
      playlist: "Playlist",
      selectLang: "Sprache wählen",
      fileNotSupported: "Dateityp nicht unterstützt. Verwenden Sie mp3, wav, ogg, aac.",
      importError: "Import der Playlist fehlgeschlagen.",
      noSongsInPlaylist: "Keine Lieder in der Playlist.",
      errorLoadingFile: "Fehler beim Laden der Datei:",
      downloadTrack: "Titel herunterladen",
      deleteDownloadedTrack: "Heruntergeladenen Titel löschen",
      downloadedAlert: "heruntergeladen!",
      downloadFailedAlert: "Fehler beim Herunterladen der Musik. Details in der Konsole.",
      deleteDownloadedAlert: "aus Downloads gelöscht.",
      deleteFailedAlert: "Fehler beim Löschen der Musik. Details in der Konsole.",
      mp3Converter: "Zum MP3-Konverter",
      preloadAllMusic: "Alle Musik vorladen",
      preloadingAll: "Lade alles vor...",
      preloading: "Vorladen",
      preloadComplete: "Vorladen abgeschlossen!",
      of: "von",
      tracks: "Titel",
      failedToPreload: "konnten nicht vorgeladen werden",
      noSongsInPlaylistToPreload: "Keine Titel in der Playlist zum Vorladen.",
      autoplayBlocked: "Autoplay blockiert. Bitte auf Play tippen oder einen Song auswählen.",

      // New headings
      playlistHeading: "Playlist",
      streamMusicHeading: "Musik streamen",
      fileManagementHeading: "Dateiverwaltung",
      toolsHeading: "Werkzeuge",
      settingsHeading: "Einstellungen",
    },
  };

  // Elements
  const container = document.getElementById('player-container');
  const coverArt = document.getElementById('cover-art');
  const playPauseBtn = document.getElementById('play-pause-btn');
  const prevBtn = document.getElementById('prev-btn');
  const nextBtn = document.getElementById('next-btn');
  const shuffleBtn = document.getElementById('shuffle-btn');
  const repeatBtn = document.getElementById('repeat-btn');
  const playlistEl = document.getElementById('playlist');
  const searchInput = document.getElementById('search-input');
  const streamUrlInput = document.getElementById('stream-url-input');
  const playStreamBtn = document.getElementById('play-stream-btn');
  const addMusicBtn = document.getElementById('add-music-btn');
  const addMusicFileInput = document.getElementById('add-music-file-input');
  const exportPlaylistBtn = document.getElementById('export-playlist-btn');
  const importPlaylistBtn = document.getElementById('import-playlist-btn');
  const importFileInput = document.getElementById('import-file-input');
  const visualizerCanvas = document.getElementById('visualizer');
  const langSelect = document.getElementById('lang-select');
  const themeColorPicker = document.getElementById('theme-color-picker');
  const mp3ConverterBtn = document.getElementById('mp3-converter-btn');
  const preloadAllBtn = document.getElementById('preload-all-btn');

  // NEW UI Elements
  const currentSongTitleEl = document.getElementById('current-song-title');
  const currentSongArtistEl = document.getElementById('current-song-artist');
  const progressBarContainer = document.getElementById('progress-bar-container');
  const progressBar = document.getElementById('progress-bar');


  // New heading elements
  const playlistHeading = document.querySelector('#main-features h3');
  const streamMusicHeading = document.querySelector('#stream-section h3');
  const fileManagementHeading = document.querySelector('#file-management-section h3');
  const toolsHeading = document.querySelector('#tools-section h3');
  const settingsHeading = document.querySelector('#settings-section h3');


  let locale = locales.en;

  // Audio & state
  const audio = new Audio();
  let playlist = []; // This will be loaded from localStorage
  let filteredPlaylist = [];
  let currentIndex = -1;
  let isPlaying = false;
  let shuffle = false;
  let repeat = false;

  // Audio context for visualization
  let audioCtx, analyser, source, dataArray, animationId;

  // IndexedDB Constants
  const IDB_DATABASE_NAME = 'music-db';
  const IDB_STORE_NAME = 'tracks';
  const LOCAL_STORAGE_PLAYLIST_KEY = 'musicPlayerPlaylist'; // Key for localStorage

  // Helper: default cover art SVG as base64 data URI
  const defaultCoverArt = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDUwIDUwIiBmaWxsPSIjNjY2NjY2IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSIyNSIgY3k9IjI1IiByPSIyMCIgZmlsbD0iI2NjY2NjY2MiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYgNiIiIHN0cm9rZT0iIzQwNDA0MCIgc3Ryb2tlLXdpZHRoPSI1Ii8+CjxwYXRoIGQ9Ik0yNSAxNWw2IDYtNiA2bTAgMTBsNiA2bS02LTYtNiA2IiBmaWxsPSIjNzc3ZjdmIi8+CjwvYXN2Zz4=`;

  // Set default UI text based on locale
  function updateLocaleTexts() {
    searchInput.placeholder = locale.searchPlaceholder;
    streamUrlInput.placeholder = locale.streamPlaceholder;
    playStreamBtn.textContent = locale.playStream;
    addMusicBtn.textContent = locale.addMusic;
    exportPlaylistBtn.textContent = locale.exportPlaylist;
    importPlaylistBtn.textContent = locale.importPlaylist;
    playPauseBtn.setAttribute('aria-label', locale.playPause);
    prevBtn.setAttribute('aria-label', locale.prevTrack);
    nextBtn.setAttribute('aria-label', locale.nextTrack);
    shuffleBtn.setAttribute('aria-label', locale.shuffle);
    repeatBtn.setAttribute('aria-label', locale.repeat);
    playlistEl.setAttribute('aria-label', locale.playlist);
    langSelect.setAttribute('aria-label', locale.selectLang);
    mp3ConverterBtn.textContent = locale.mp3Converter;
    preloadAllBtn.textContent = locale.preloadAllMusic;

    // Update section headings
    playlistHeading.textContent = locale.playlistHeading;
    streamMusicHeading.textContent = locale.streamMusicHeading;
    fileManagementHeading.textContent = locale.fileManagementHeading;
    toolsHeading.textContent = locale.toolsHeading;
    settingsHeading.textContent = locale.settingsHeading;

    if(currentIndex === -1) {
        coverArt.alt = locale.noTrack;
        currentSongTitleEl.textContent = locale.noTrack;
        currentSongArtistEl.textContent = '';
    }
  }

  updateLocaleTexts();

  // Utilities
  function isSupportedFileType(fileName) {
    return /\.(mp3|wav|ogg|aac)$/i.test(fileName);
  }

  // Extract basic metadata from file or URL (title from filename)
  // For simplicity, no ID3 parsing, just filename for title
  function createTrackObject(fileOrUrl) {
    let title = '', artist = '', url = '', cover = defaultCoverArt;
    if(typeof fileOrUrl === 'string') {
      // Streaming URL
      url = fileOrUrl;
      title = url.split('/').pop().split('?')[0] || 'Streaming Track';
      artist = '';
    } else {
      // File object
      url = URL.createObjectURL(fileOrUrl);
      title = fileOrUrl.name.replace(/\.[^/.]+$/, "");
      artist = '';
    }
    // Add new properties for download feature
    return {title, artist, url, cover, isDownloaded: false, offlineUrl: null};
  }

  // Helper to open IndexedDB
  async function openIndexedDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(IDB_DATABASE_NAME, 1); // Version 1

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(IDB_STORE_NAME)) {
          db.createObjectStore(IDB_STORE_NAME, { keyPath: 'id' });
        }
      };

      request.onsuccess = (event) => {
        resolve(event.target.result);
      };

      request.onerror = (event) => {
        console.error('IndexedDB error:', event.target.error);
        reject(event.target.error);
      };
    });
  }

  // Function to download and store a track
  async function downloadAndStoreTrack(track) {
    if (!track || !track.url) {
      console.error('Invalid track object for download:', track);
      return false;
    }
    if (track.isDownloaded) {
        console.log(`Track "${track.title}" is already downloaded.`);
        return true;
    }

    const trackId = `track_${btoa(track.url).replace(/=/g, '')}_${Date.now()}`;

    try {
      const db = await openIndexedDB();
      const response = await fetch(track.url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const audioBlob = await response.blob();
      const mimeType = response.headers.get('Content-Type') || 'audio/mpeg';

      const transaction = db.transaction([IDB_STORE_NAME], 'readwrite');
      const store = transaction.objectStore(IDB_STORE_NAME);

      const dataToStore = {
        id: trackId,
        title: track.title,
        artist: track.artist,
        originalUrl: track.url,
        audioBlob: audioBlob,
        mimeType: mimeType,
        cover: track.cover || defaultCoverArt,
      };

      await store.add(dataToStore);

      const originalTrackIndex = playlist.findIndex(t => t.url === track.url);
      if (originalTrackIndex !== -1) {
        playlist[originalTrackIndex].offlineUrl = `indexeddb://${trackId}`;
        playlist[originalTrackIndex].isDownloaded = true;
        renderPlaylist();
        savePlaylist(); // Save playlist after download status changes
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error downloading and storing track:', error);
      alert(`${locale.downloadFailedAlert}`);
      return false;
    }
  }

  // Function to delete a track from IndexedDB
  async function deleteStoredTrack(track) {
      if (!track || !track.offlineUrl) return false;

      const urlObj = new URL(track.offlineUrl);
      if (urlObj.protocol !== 'indexeddb:') {
          console.warn('Track is not an IndexedDB URL, cannot delete:', track.offlineUrl);
          return false;
      }
      const trackId = urlObj.hostname;

      try {
          const db = await openIndexedDB();
          const transaction = db.transaction([IDB_STORE_NAME], 'readwrite');
          const store = transaction.objectStore(IDB_STORE_NAME);

          await store.delete(trackId);

          const originalTrackIndex = playlist.findIndex(t => t.offlineUrl === track.offlineUrl);
          if (originalTrackIndex !== -1) {
              delete playlist[originalTrackIndex].offlineUrl;
              playlist[originalTrackIndex].isDownloaded = false;
              renderPlaylist();
              savePlaylist(); // Save playlist after download status changes
              return true;
          }
          return false;
      } catch (error) {
          console.error('Error deleting track from IndexedDB:', error);
          alert(`${locale.deleteFailedAlert}`);
          return false;
      }
  }

  // Function to check if a track is downloaded
  async function isTrackDownloaded(track) {
    if (!track || !track.url) return false;

    try {
      const db = await openIndexedDB();
      const transaction = db.transaction([IDB_STORE_NAME], 'readonly');
      const store = transaction.objectStore(IDB_STORE_NAME);
      
      return new Promise((resolve) => {
        const request = store.openCursor();
        request.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            // Check if the originalUrl matches
            if (cursor.value.originalUrl === track.url) {
              track.offlineUrl = `indexeddb://${cursor.value.id}`;
              track.isDownloaded = true;
              resolve(true);
              return;
            }
            cursor.continue();
          } else {
            resolve(false);
          }
        };
        request.onerror = () => {
          console.error("Error checking download status:", event.target.error);
          resolve(false);
        };
      });
    } catch (error) {
        console.error("Could not open IndexedDB to check download status:", error);
        return false;
    }
  }

  // Populate playlist with tracks and update download status
  async function checkAllTracksDownloadStatus() {
    for (const track of playlist) {
      await isTrackDownloaded(track);
    }
    renderPlaylist(); // Render after checking all statuses
  }

  // Function to preload all tracks in the playlist
  async function preloadAllMusic() {
    if (playlist.length === 0) {
        alert(locale.noSongsInPlaylistToPreload);
        return;
    }

    preloadAllBtn.disabled = true;
    preloadAllBtn.textContent = locale.preloadingAll;

    let downloadedCount = 0;
    let failedCount = 0;

    for (const track of playlist) {
        if (track.isDownloaded) {
            downloadedCount++;
            continue;
        }

        const success = await downloadAndStoreTrack(track);
        if (success) {
            downloadedCount++;
        } else {
            failedCount++;
        }
        preloadAllBtn.textContent = `${locale.preloading} (${downloadedCount}/${playlist.length})`;
    }

    preloadAllBtn.disabled = false;
    preloadAllBtn.textContent = locale.preloadAllMusic;

    let message = `${locale.preloadComplete} ${downloadedCount} ${locale.of} ${playlist.length} ${locale.tracks}.`;
    if (failedCount > 0) {
        message += ` ${failedCount} ${locale.failedToPreload}.`;
    }
    alert(message);
  }

  // --- Playlist Persistence (LocalStorage) ---

  // Save playlist to LocalStorage
  function savePlaylist() {
    try {
      // We only save the necessary properties to keep the JSON size down
      const simplePlaylist = playlist.map(track => ({
        title: track.title,
        artist: track.artist,
        url: track.url,
        cover: track.cover
      }));
      localStorage.setItem(LOCAL_STORAGE_PLAYLIST_KEY, JSON.stringify(simplePlaylist));
      console.log('Playlist saved to LocalStorage.');
    } catch (e) {
      console.error('Error saving playlist to LocalStorage:', e);
    }
  }

  // Load playlist from LocalStorage
  function loadPlaylist() {
    try {
      const storedPlaylist = localStorage.getItem(LOCAL_STORAGE_PLAYLIST_KEY);
      if (storedPlaylist) {
        const loadedTracks = JSON.parse(storedPlaylist);
        // Reconstruct the full track object, ensuring isDownloaded/offlineUrl are correctly re-evaluated
        playlist = loadedTracks.map(t => ({
            title: t.title || 'Unknown Title',
            artist: t.artist || 'Unknown Artist',
            url: t.url,
            cover: t.cover || defaultCoverArt,
            isDownloaded: false, // Will be updated by checkAllTracksDownloadStatus
            offlineUrl: null     // Will be updated by checkAllTracksDownloadStatus
        }));
        console.log('Playlist loaded from LocalStorage.');
      } else {
        playlist = []; // Start with an empty playlist if nothing saved
        console.log('No playlist found in LocalStorage.');
      }
    } catch (e) {
      console.error('Error loading playlist from LocalStorage:', e);
      playlist = []; // Fallback to empty playlist on error
    }
  }


  // Render playlist items filtered by searchInput.value
  function renderPlaylist() {
    playlistEl.innerHTML = '';

    const searchTerm = searchInput.value.trim().toLowerCase();

    filteredPlaylist = playlist.filter(track => {
      return (
        track.title.toLowerCase().includes(searchTerm) ||
        track.artist.toLowerCase().includes(searchTerm)
      );
    });

    if(filteredPlaylist.length === 0) {
      const emptyMsg = document.createElement('li');
      emptyMsg.textContent = locale.noSongsInPlaylist;
      emptyMsg.style.padding = '10px 20px';
      emptyMsg.style.color = '#777';
      playlistEl.appendChild(emptyMsg);
      return;
    }

    filteredPlaylist.forEach((track, idx) => { // Original 'idx' here is the index in filteredPlaylist
        const originalIndex = playlist.indexOf(track); // Get the actual index in the main playlist

        const item = document.createElement('li');
        item.className = 'playlist-item';
        item.tabIndex = 0;
        item.dataset.originalIdx = originalIndex; // Store original index for operations

        if(originalIndex === currentIndex) {
            item.classList.add('active');
        }

        const img = document.createElement('img');
        img.src = track.cover || defaultCoverArt;
        img.alt = "";

        const titleArtist = document.createElement('div');
        titleArtist.className = 'title-artist';

        const titleEl = document.createElement('div');
        titleEl.className = 'title';
        titleEl.textContent = track.title;

        const artistEl = document.createElement('div');
        artistEl.className = 'artist';
        artistEl.textContent = track.artist;

        titleArtist.appendChild(titleEl);
        titleArtist.appendChild(artistEl);

        item.appendChild(img);
        item.appendChild(titleArtist);

        // --- Existing Download/Delete Buttons ---
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'download-btn';
        downloadBtn.setAttribute('aria-label', locale.downloadTrack);
        downloadBtn.textContent = '⬇️';
        downloadBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            downloadBtn.disabled = true;
            downloadBtn.textContent = '⏳';
            const success = await downloadAndStoreTrack(track);
            if (success) {
                alert(`"${track.title}" ${locale.downloadedAlert}`);
            }
            downloadBtn.disabled = false;
            renderPlaylist();
        });
        item.appendChild(downloadBtn);

        const deleteDownloadBtn = document.createElement('button'); // Renamed for clarity
        deleteDownloadBtn.className = 'delete-download-btn';
        deleteDownloadBtn.setAttribute('aria-label', locale.deleteDownloadedTrack);
        deleteDownloadBtn.textContent = '🗑️';
        deleteDownloadBtn.style.display = 'none';
        deleteDownloadBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            deleteDownloadBtn.disabled = true;
            const success = await deleteStoredTrack(track);
            if (success) {
                alert(`"${track.title}" ${locale.deleteDownloadedAlert}`);
            }
            deleteDownloadBtn.disabled = false;
            renderPlaylist();
        });
        item.appendChild(deleteDownloadBtn);

        if (track.isDownloaded) {
            downloadBtn.style.display = 'none';
            deleteDownloadBtn.style.display = 'block';
        } else {
            downloadBtn.style.display = 'block';
            deleteDownloadBtn.style.display = 'none';
        }

        // --- NEW Playlist Management Buttons ---
        const playlistItemControls = document.createElement('div');
        playlistItemControls.className = 'playlist-item-controls';

        const moveUpBtn = document.createElement('button');
        moveUpBtn.className = 'move-up-btn';
        moveUpBtn.setAttribute('aria-label', 'Move track up');
        moveUpBtn.textContent = '⬆️';
        if (originalIndex === 0) { // Disable if already at the top
            moveUpBtn.disabled = true;
            moveUpBtn.style.opacity = 0.3;
            moveUpBtn.style.cursor = 'not-allowed';
        }
        moveUpBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent playing the song
            moveTrackInPlaylist(originalIndex, originalIndex - 1);
        });
        playlistItemControls.appendChild(moveUpBtn);

        const moveDownBtn = document.createElement('button');
        moveDownBtn.className = 'move-down-btn';
        moveDownBtn.setAttribute('aria-label', 'Move track down');
        moveDownBtn.textContent = '⬇️';
        if (originalIndex === playlist.length - 1) { // Disable if already at the bottom
            moveDownBtn.disabled = true;
            moveDownBtn.style.opacity = 0.3;
            moveDownBtn.style.cursor = 'not-allowed';
        }
        moveDownBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent playing the song
            moveTrackInPlaylist(originalIndex, originalIndex + 1);
        });
        playlistItemControls.appendChild(moveDownBtn);

        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-from-playlist-btn';
        removeBtn.setAttribute('aria-label', 'Remove track from playlist');
        removeBtn.textContent = '✖️';
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent playing the song
            removeTrackFromPlaylist(originalIndex);
        });
        playlistItemControls.appendChild(removeBtn);

        item.appendChild(playlistItemControls); // Add the controls container to the item

        // --- Existing Play/Keyboard Event Listeners ---
        item.addEventListener('click', () => {
            const urlToPlay = track.isDownloaded ? track.offlineUrl : track.url;
            playTrack(originalIndex, urlToPlay); // Use originalIndex for playing
        });
        item.addEventListener('keydown', (e) => {
            if(e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                const urlToPlay = track.isDownloaded ? track.offlineUrl : track.url;
                playTrack(originalIndex, urlToPlay); // Use originalIndex for playing
            }
        });

        playlistEl.appendChild(item);
    });
  }

  // Load & play a track by index
  function playTrack(idx, urlToPlay = null) {
    if(idx < 0 || idx >= playlist.length) return;

    currentIndex = idx;
    const track = playlist[currentIndex];
    audio.src = urlToPlay || track.url;

    // Update current song info display
    currentSongTitleEl.textContent = track.title;
    currentSongArtistEl.textContent = track.artist;
    coverArt.alt = `Cover art for ${track.title} by ${track.artist}`;


    audio.play()
      .then(() => {
        isPlaying = true;
        updatePlayPauseButton();
        updateCoverArt(track.cover);
        updatePlaylistActive();
      })
      .catch((error) => {
        isPlaying = false; // Ensure UI reflects paused state
        updatePlayPauseButton();
        console.error("Audio playback failed:", error);
        // More specific error message for autoplay
        if (error.name === 'NotAllowedError' || error.name === 'AbortError') {
          alert(locale.autoplayBlocked);
        } else {
          alert("Failed to play track. Make sure your browser allows autoplay or try interacting with the page first.");
        }
      });
  }

  // Play next track
  function playNext() {
    if(playlist.length === 0) return;

    if(shuffle) {
      let nextIdx;
      do {
        nextIdx = Math.floor(Math.random() * playlist.length);
      } while (nextIdx === currentIndex && playlist.length > 1);
      playTrack(nextIdx, playlist[nextIdx].isDownloaded ? playlist[nextIdx].offlineUrl : playlist[nextIdx].url);
    } else {
      if(currentIndex + 1 < playlist.length) {
        playTrack(currentIndex + 1, playlist[currentIndex + 1].isDownloaded ? playlist[currentIndex + 1].offlineUrl : playlist[currentIndex + 1].url);
      } else if(repeat) {
        playTrack(0, playlist[0].isDownloaded ? playlist[0].offlineUrl : playlist[0].url);
      } else {
        pauseAudio();
      }
    }
  }

  // Play previous track
  function playPrev() {
    if(playlist.length === 0) return;

    if(shuffle) {
      let prevIdx;
      do {
        prevIdx = Math.floor(Math.random() * playlist.length);
      } while (prevIdx === currentIndex && playlist.length > 1);
      playTrack(prevIdx, playlist[prevIdx].isDownloaded ? playlist[prevIdx].offlineUrl : playlist[prevIdx].url);
    } else {
      if(currentIndex > 0) {
        playTrack(currentIndex - 1, playlist[currentIndex - 1].isDownloaded ? playlist[currentIndex - 1].offlineUrl : playlist[currentIndex - 1].url);
      } else if(repeat) {
        playTrack(playlist.length - 1, playlist[playlist.length - 1].isDownloaded ? playlist[playlist.length - 1].offlineUrl : playlist[playlist.length - 1].url);
      } else {
        pauseAudio();
      }
    }
  }

  // Toggle play/pause
  function togglePlayPause() {
    if(isPlaying) {
      pauseAudio();
    } else {
      if(currentIndex === -1 && playlist.length > 0) {
        // If no song is selected, try to play the first one
        playTrack(0, playlist[0].isDownloaded ? playlist[0].offlineUrl : playlist[0].url);
      } else if (currentIndex !== -1) {
        // If a song is selected, try to resume it
        playTrack(currentIndex, playlist[currentIndex].isDownloaded ? playlist[currentIndex].offlineUrl : playlist[currentIndex].url);
      } else {
          console.log("No tracks available to play.");
      }
    }
  }

  function pauseAudio() {
    audio.pause();
    isPlaying = false;
    updatePlayPauseButton();
  }

  // Update UI play/pause icon
  function updatePlayPauseButton() {
    playPauseBtn.textContent = isPlaying ? "⏸" : "▶️";
  }

  // Update cover art
  function updateCoverArt(url) {
    coverArt.src = url || defaultCoverArt;
    // Alt text is handled in playTrack for now, but can be updated here for consistency
  }

  // Update active playlist item highlight
  function updatePlaylistActive() {
    const items = playlistEl.querySelectorAll('.playlist-item');
    items.forEach(item => {
      item.classList.remove('active');
      if(parseInt(item.dataset.originalIdx, 10) === currentIndex) { // Use originalIdx here
        item.classList.add('active');
        item.scrollIntoView({behavior: 'smooth', block: 'nearest'});
      }
    });
  }

  // Shuffle toggle
  function toggleShuffle() {
    shuffle = !shuffle;
    shuffleBtn.setAttribute('aria-pressed', shuffle);
    shuffleBtn.style.color = shuffle ? 'var(--primary-color)' : '';
  }

  // Repeat toggle
  function toggleRepeat() {
    repeat = !repeat;
    repeatBtn.setAttribute('aria-pressed', repeat);
    repeatBtn.style.color = repeat ? 'var(--primary-color)' : '';
  }

  // Play streaming URL
  function playStream() {
    const url = streamUrlInput.value.trim();
    if(!url) return;
    // Call playTrack with the streaming URL as a new track object
    const streamTrack = createTrackObject(url);
    // Add stream track to playlist if not already there, or play if it is
    const existingIndex = playlist.findIndex(t => t.url === url);
    if (existingIndex === -1) {
        playlist.push(streamTrack);
        savePlaylist(); // Save playlist after adding stream track
        playTrack(playlist.length - 1);
    } else {
        playTrack(existingIndex);
    }
  }

  // Export playlist to JSON file
  function exportPlaylist() {
    if(playlist.length === 0) {
      alert(locale.noSongsInPlaylist);
      return;
    }
    const exportablePlaylist = playlist.map(track => ({
      title: track.title,
      artist: track.artist,
      url: track.url,
      cover: track.cover,
      // Do not export isDownloaded and offlineUrl as they are runtime/local cache specific
    }));

    const json = JSON.stringify(exportablePlaylist, null, 2);
    const blob = new Blob([json], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "playlist.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // Import playlist from JSON file
  function importPlaylistFromFile(file) {
    if(!file) return;
    const reader = new FileReader();
    reader.onload = async e => {
      try {
        const imported = JSON.parse(e.target.result);
        if(Array.isArray(imported)) {
          // Clear existing playlist and add imported tracks
          playlist = imported.map(t => ({
              title: t.title || 'Unknown Title',
              artist: t.artist || 'Unknown Artist',
              url: t.url,
              cover: t.cover || defaultCoverArt,
              isDownloaded: false, // Reset download status for imported tracks
              offlineUrl: null,    // Reset offline URL
          })).filter(t => t.url); // Ensure tracks have a URL

          currentIndex = -1; // Reset current playing track
          isPlaying = false;
          audio.pause();
          audio.src = "";
          updateCoverArt(defaultCoverArt);
          savePlaylist(); // Save imported playlist
          await checkAllTracksDownloadStatus(); // Check download status for imported tracks
          updatePlayPauseButton();
          currentSongTitleEl.textContent = locale.noTrack; // Reset current song info
          currentSongArtistEl.textContent = '';
          progressBar.style.width = '0%'; // Reset progress bar
        } else {
          alert(locale.importError);
        }
      } catch (error) {
        console.error("Import playlist error:", error);
        alert(locale.importError);
      }
    };
    reader.readAsText(file);
  }

  // Handle files selected via input[type="file"] or drag-and-drop
  function handleFilesFromInput(files) {
    const accepted = Array.from(files).filter(f => isSupportedFileType(f.name));
    if (accepted.length === 0) {
      alert(locale.fileNotSupported);
      return;
    }
    accepted.forEach(file => {
      const track = createTrackObject(file);
      // Prevent duplicates based on URL (important for local files too)
      if (!playlist.some(t => t.url === track.url)) {
        playlist.push(track);
      }
    });
    savePlaylist(); // Save playlist after adding new files
    checkAllTracksDownloadStatus(); // Re-render and check download status after adding new files
  }

  // Drag & drop handlers for files
  function onDragOver(e) {
    e.preventDefault();
    container.classList.add('dragover');
  }
  function onDragLeave(e) {
    e.preventDefault();
    container.classList.remove('dragover');
  }
  function onDrop(e) {
    e.preventDefault();
    container.classList.remove('dragover');
    handleFilesFromInput(e.dataTransfer.files); // Use the unified file handling
  }

  // Keyboard shortcuts
  function onKeyDown(e) {
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

    switch(e.key.toLowerCase()) {
      case ' ':
        e.preventDefault();
        togglePlayPause();
        break;
      case 'arrowright':
        e.preventDefault();
        playNext();
        break;
      case 'arrowleft':
        e.preventDefault();
        playPrev();
        break;
      case 's':
        e.preventDefault();
        toggleShuffle();
        break;
      case 'r':
        e.preventDefault();
        toggleRepeat();
        break;
    }
  }

  // Visualizer setup
  function setupVisualizer() {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)(); // Use webkitAudioContext for broader compatibility
      analyser = audioCtx.createAnalyser();
      source = audioCtx.createMediaElementSource(audio);
      source.connect(analyser);
      analyser.connect(audioCtx.destination);
      analyser.fftSize = 256;
      const bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array(bufferLength);

      const canvasCtx = visualizerCanvas.getContext('2d');
      // Set canvas dimensions dynamically based on client size
      const WIDTH = visualizerCanvas.width = visualizerCanvas.clientWidth;
      const HEIGHT = visualizerCanvas.height = visualizerCanvas.clientHeight;

      function draw() {
        animationId = requestAnimationFrame(draw);
        analyser.getByteFrequencyData(dataArray);

        canvasCtx.fillStyle = '#181818';
        canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

        const barWidth = (WIDTH / bufferLength) * 1.5;
        let x = 0;
        for(let i = 0; i < bufferLength; i++) {
          const barHeight = dataArray[i] / 2;
          const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
          canvasCtx.fillStyle = primaryColor;
          canvasCtx.fillRect(x, HEIGHT - barHeight, barWidth, barHeight);
          x += barWidth + 1;
        }
      }

      draw();
    } catch(e) {
      console.warn("Visualizer not supported or audio context could not be started.", e);
    }
  }

  // Resize visualizer canvas on window resize
  window.addEventListener('resize', () => {
    if(visualizerCanvas) {
      visualizerCanvas.width = visualizerCanvas.clientWidth;
      visualizerCanvas.height = visualizerCanvas.clientHeight;
    }
  });

  // NEW: Playlist editing functions
  function moveTrackInPlaylist(oldIndex, newIndex) {
      if (newIndex < 0 || newIndex >= playlist.length || oldIndex === newIndex) {
          return; // Invalid move
      }

      const [movedTrack] = playlist.splice(oldIndex, 1);
      playlist.splice(newIndex, 0, movedTrack);

      // If the currently playing track was moved, update its index
      if (currentIndex === oldIndex) {
          currentIndex = newIndex;
      } else if (currentIndex > oldIndex && currentIndex <= newIndex) {
          currentIndex--; // Adjust index if track moved past current
      } else if (currentIndex < oldIndex && currentIndex >= newIndex) {
          currentIndex++; // Adjust index if track moved into current's original spot
      }

      savePlaylist();
      renderPlaylist(); // Re-render to reflect new order
      updatePlaylistActive(); // Ensure active class is correct after re-render
  }

  function removeTrackFromPlaylist(indexToRemove) {
      if (indexToRemove < 0 || indexToRemove >= playlist.length) {
          return; // Invalid index
      }

      const removedTrack = playlist.splice(indexToRemove, 1)[0];

      // If the removed track was the currently playing one
      if (currentIndex === indexToRemove) {
          pauseAudio(); // Pause playback
          currentIndex = -1; // No track selected
          updateCoverArt(defaultCoverArt);
          currentSongTitleEl.textContent = locale.noTrack; // Reset current song info
          currentSongArtistEl.textContent = '';
          progressBar.style.width = '0%'; // Reset progress bar
          updatePlayPauseButton();
      } else if (currentIndex > indexToRemove) {
          currentIndex--; // Adjust current index if a track before it was removed
      }

      savePlaylist();
      renderPlaylist(); // Re-render to reflect removal
      updatePlaylistActive(); // Update active class (might be none)
      console.log(`Track "${removedTrack.title}" removed from playlist.`);
  }

  // Progress Bar Logic
  function updateProgressBar() {
    const progress = (audio.currentTime / audio.duration) * 100;
    progressBar.style.width = `${progress || 0}%`;
  }

  function seekAudio(e) {
    const rect = progressBarContainer.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const width = rect.width;
    const seekTime = (clickX / width) * audio.duration;
    audio.currentTime = seekTime;
  }

  // Helper to convert hex to RGB for dynamic RGBA colors
  function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `${r}, ${g}, ${b}`;
  }


  // Initialize
  function init() {
    // 1. Load playlist from LocalStorage
    loadPlaylist();

    // Event listeners
    playPauseBtn.addEventListener('click', togglePlayPause);
    prevBtn.addEventListener('click', playPrev);
    nextBtn.addEventListener('click', playNext);
    shuffleBtn.addEventListener('click', toggleShuffle);
    repeatBtn.addEventListener('click', toggleRepeat);
    searchInput.addEventListener('input', renderPlaylist);
    playStreamBtn.addEventListener('click', playStream);

    addMusicBtn.addEventListener('click', () => addMusicFileInput.click());
    addMusicFileInput.addEventListener('change', (e) => {
      handleFilesFromInput(e.target.files);
      addMusicFileInput.value = ''; // Clear input to allow adding same file again
    });

    exportPlaylistBtn.addEventListener('click', exportPlaylist);
    importPlaylistBtn.addEventListener('click', () => importFileInput.click());
    importFileInput.addEventListener('change', e => {
      importPlaylistFromFile(e.target.files[0]);
      importFileInput.value = ''; // Clear input
    });
    mp3ConverterBtn.addEventListener('click', () => {
        window.open('https://www.freeconvert.com/mp3-converter', '_blank');
    });
    preloadAllBtn.addEventListener('click', preloadAllMusic);

    container.addEventListener('dragover', onDragOver);
    container.addEventListener('dragleave', onDragLeave);
    container.addEventListener('drop', onDrop);

    window.addEventListener('keydown', onKeyDown);

    audio.addEventListener('ended', playNext);
    audio.addEventListener('timeupdate', updateProgressBar); // Update progress bar
    progressBarContainer.addEventListener('click', seekAudio); // Seek functionality

    // audio.addEventListener('play') and 'pause' listeners now largely handled by playTrack promise
    audio.addEventListener('play', () => {
      isPlaying = true;
      updatePlayPauseButton();
      if(audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume().catch(e => console.error("Failed to resume AudioContext:", e));
      }
    });
    audio.addEventListener('pause', () => {
      isPlaying = false;
      updatePlayPauseButton();
    });

    langSelect.addEventListener('change', () => {
      const val = langSelect.value;
      locale = locales[val] || locales.en;
      updateLocaleTexts();
      renderPlaylist();
    });

    themeColorPicker.addEventListener('input', (e) => {
      const newColor = e.target.value;
      document.documentElement.style.setProperty('--primary-color', newColor);
      // Set RGB variable for dynamic RGBA in CSS
      document.documentElement.style.setProperty('--primary-color-rgb', hexToRgb(newColor));
      updatePlaylistActive(); // Reapply active style with new color
    });
    // Set initial RGB variable
    document.documentElement.style.setProperty('--primary-color-rgb', hexToRgb(themeColorPicker.value));


    updateCoverArt(defaultCoverArt);
    // Ensure playlist is rendered and download status checked before attempting autoplay
    // This now happens AFTER loadPlaylist()
    checkAllTracksDownloadStatus().then(() => {
      if (playlist.length > 0) {
        // Attempt to autoplay the first track
        // playTrack(0, playlist[0].isDownloaded ? playlist[0].offlineUrl : playlist[0].url);
        // Better: just set the current song info and cover art for the first song without auto-playing
        const firstTrack = playlist[0];
        currentSongTitleEl.textContent = firstTrack.title;
        currentSongArtistEl.textContent = firstTrack.artist;
        updateCoverArt(firstTrack.cover);
      } else {
        updateLocaleTexts(); // Set "No track playing" if playlist is empty
      }
    });

    setupVisualizer();

    // Service Worker Registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered with scope:', registration.scope);
          })
          .catch((error) => {
            console.error('Service Worker registration failed:', error);
          });
      });
    }
  }

  init();

})();
</script>
</body>
</html>
