<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Music Player</title>

<link rel="manifest" href="/manifest.json">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Music Player">
<link rel="apple-touch-icon" href="/icons/icon-192x192.png">

<style>
  /* Reset */
  * {
    box-sizing: border-box;
  }

  :root {
    --primary-color: #ff6f61; /* Define a CSS variable for the primary color */
    --background-dark: #121212;
    --background-medium: #1e1e1e;
    --background-light: #272727;
    --text-color: #eee;
    --text-muted: #aaa;
    --border-color: #2a2a2a;
    --shadow-color: rgba(0, 0, 0, 0.6);
    --primary-color-rgb: 255, 111, 97; /* Default RGB for primary color */
  }

  body {
    margin: 0;
    background-color: var(--background-dark);
    color: var(--text-color);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center; /* Center vertically */
    padding: 20px;
    min-height: 100vh;
    overflow-y: auto; /* Allow scrolling if content is taller than viewport */
  }

  #player-container {
    background: var(--background-medium);
    width: 360px;
    max-width: 100%; /* Ensure responsiveness on smaller screens */
    border-radius: 16px;
    box-shadow: 0 10px 30px var(--shadow-color); /* Enhanced shadow */
    overflow: hidden;
    display: flex;
    flex-direction: column;
    user-select: none;
    margin: auto; /* Center horizontally if max-width is hit */
  }

  /* Section Grouping Styles - Renamed to features-group */
  .features-group {
    padding: 15px 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    border-top: 1px solid var(--border-color);
  }

  .features-group:first-of-type {
    border-top: none;
  }

  .features-group h3 {
    margin: 0;
    color: var(--primary-color);
    font-size: 1.1em; /* Slightly larger heading */
    text-transform: uppercase;
    letter-spacing: 0.8px; /* More prominent spacing */
    padding-bottom: 5px; /* Space below heading */
  }

  /* Cover Art & Controls */
  #player-header {
    position: relative; /* For current song info overlay */
    background: var(--background-medium);
  }

  #cover-art {
    width: 100%;
    aspect-ratio: 1/1;
    object-fit: cover;
    display: block; /* Remove extra space below image */
    box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.8); /* Darker inner shadow */
    background: #2a2a2a;
  }

  #current-song-info {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
    padding: 20px 20px 10px 20px; /* More padding at bottom */
    color: #fff;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    opacity: 0; /* Hidden by default */
    transition: opacity 0.3s ease-in-out;
  }

  #player-header:hover #current-song-info {
    opacity: 1; /* Show on hover */
  }

  #current-song-info .title {
    font-size: 1.2em; /* Larger title */
    font-weight: 700;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  #current-song-info .artist {
    font-size: 0.9em;
    color: #ccc;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  #playback-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 14px;
    padding: 15px 20px;
    background: var(--background-light); /* Slightly lighter for controls */
    border-top: 1px solid var(--border-color);
    position: relative; /* For progress bar positioning */
  }

  #progress-bar-container {
    position: absolute;
    top: 0; /* Position at the very top of the controls div */
    left: 0;
    width: 100%;
    height: 6px; /* Slimmer progress bar */
    background-color: #383838;
    cursor: pointer;
    border-radius: 3px 3px 0 0; /* Rounded top corners */
  }

  #progress-bar {
    height: 100%;
    width: 0%;
    background-color: var(--primary-color);
    border-radius: 3px 3px 0 0;
    transition: width 0.1s linear; /* Smoother progress animation */
  }

  #playback-controls button {
    background: #333;
    border: none;
    border-radius: 50%;
    width: 42px;
    height: 42px;
    color: var(--text-color);
    font-size: 18px;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease; /* Add transform transition */
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3); /* Subtle button shadow */
  }

  #playback-controls button:hover,
  #playback-controls button:focus {
    background-color: var(--primary-color);
    outline: none;
    transform: translateY(-2px); /* Slight lift on hover */
  }

  #play-pause-btn {
    width: 54px;
    height: 54px;
    font-size: 22px;
    background: var(--primary-color);
    box-shadow: 0 0 12px rgba(var(--primary-color-rgb), 0.6); /* More pronounced glow */
  }

  #play-pause-btn:hover,
  #play-pause-btn:focus {
    background: #ff4b3f;
    box-shadow: 0 0 16px rgba(var(--primary-color-rgb), 0.8);
    transform: scale(1.05); /* Slightly larger on hover */
  }

  /* Tab Navigation */
  #tab-navigation {
    display: flex;
    background: var(--background-light);
    border-top: 1px solid var(--border-color);
  }

  #tab-navigation button {
    flex: 1;
    padding: 15px 0;
    background: none;
    border: none;
    color: var(--text-muted);
    font-size: 1.1em;
    font-weight: 600;
    cursor: pointer;
    transition: color 0.3s ease, background-color 0.3s ease;
    border-bottom: 3px solid transparent;
    outline: none;
  }

  #tab-navigation button.active {
    color: var(--primary-color);
    border-bottom-color: var(--primary-color);
    background-color: var(--background-medium);
  }

  #tab-navigation button:hover:not(.active) {
    color: var(--text-color);
    background-color: #333;
  }

  /* Tab Content */
  .tab-content {
    display: none; /* Hidden by default */
    background: var(--background-dark);
    flex-grow: 1; /* Allow content to take available space */
    min-height: 200px; /* Ensure a minimum height for tab content */
  }

  .tab-content.active {
    display: flex; /* Show active tab */
    flex-direction: column;
  }

  #search-input {
    width: calc(100% - 40px);
    margin: 15px 20px 0px 20px; /* Adjusted top margin */
    padding: 10px 15px; /* More padding */
    border-radius: 10px; /* Slightly more rounded */
    border: none;
    font-size: 15px; /* Slightly larger font */
    background-color: var(--background-light);
    color: var(--text-color);
    outline: none;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
  }

  #search-input::placeholder {
    color: #777;
  }

  #search-input:focus {
    background-color: #3c3c3c;
    box-shadow: 0 0 0 2px var(--primary-color); /* Focus ring */
  }

  /* Active Filter Display */
  #active-filter-display {
    padding: 10px 20px;
    background-color: var(--background-light);
    color: var(--text-color);
    font-size: 0.9em;
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    margin-top: 15px;
    opacity: 0; /* Hidden by default */
    transition: opacity 0.3s ease;
  }

  #active-filter-display.active {
    opacity: 1;
  }

  #active-filter-display button {
    background: none;
    border: none;
    color: var(--primary-color);
    font-size: 1em;
    cursor: pointer;
    transition: color 0.2s ease;
  }
  #active-filter-display button:hover {
    color: #fff;
  }


  #playlist {
    max-height: 280px; /* Still maintains height within tab */
    overflow-y: auto;
    background: var(--background-dark);
    padding: 8px 0;
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) #2a2a2a;
    border-top: none; /* No border top within tab content */
    list-style: none; /* Remove default list bullets */
    flex-grow: 1; /* Allow playlist to take remaining height */
  }

  #playlist::-webkit-scrollbar {
    width: 8px;
  }

  #playlist::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 4px;
  }

  .playlist-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 20px;
    cursor: pointer;
    transition: background-color 0.25s ease, transform 0.1s ease;
    border-left: 4px solid transparent;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    user-select:none;
    position: relative;
    padding-right: 120px; /* Make space for the new controls */
  }

  .playlist-item:hover {
    background-color: #272727;
    transform: translateX(3px); /* Subtle slide on hover */
  }

  .playlist-item.active {
    background-color: rgba(var(--primary-color-rgb), 0.2); /* Semi-transparent primary */
    border-left-color: var(--primary-color);
    color: var(--text-color);
  }


  .playlist-item img {
    width: 40px; /* Slightly larger image */
    height: 40px;
    object-fit: cover;
    border-radius: 8px; /* More rounded corners */
    box-shadow: 0 2px 8px rgba(0,0,0,0.4); /* Enhanced image shadow */
    flex-shrink: 0;
  }

  .title-artist {
    display: flex;
    flex-direction: column;
    font-size: 14px;
    overflow: hidden;
    flex-grow: 1; /* Allow title/artist to take available space */
  }

  .title-artist .title {
    font-weight: 600;
    color: #fff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .title-artist .artist {
    font-weight: 400;
    color: var(--text-muted); /* Use muted text color */
    font-size: 12px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Download/Delete/Edit buttons */
  .download-btn,
  .delete-download-btn,
  .edit-info-btn {
    background: none;
    border: none;
    color: var(--text-muted); /* Muted color */
    font-size: 1.2em;
    cursor: pointer;
    opacity: 0.7; /* Slightly less opaque */
    transition: opacity 0.2s ease, transform 0.2s ease;
    padding: 5px;
    border-radius: 4px;
    flex-shrink: 0; /* Prevent shrinking */
  }

  .download-btn:hover,
  .download-btn:focus,
  .delete-download-btn:hover,
  .delete-download-btn:focus,
  .edit-info-btn:hover,
  .edit-info-btn:focus {
    opacity: 1;
    background-color: rgba(255, 255, 255, 0.15); /* Slightly brighter hover */
    outline: none;
    transform: scale(1.1); /* Pop out slightly */
  }

  .delete-download-btn {
    color: #ff4b3f; /* Red for delete */
  }

  .download-btn:disabled,
  .delete-download-btn:disabled,
  .edit-info-btn:disabled {
    cursor: not-allowed;
    opacity: 0.3; /* More faded when disabled */
    transform: none; /* No transform when disabled */
  }

  /* Playlist management buttons */
  .playlist-item-controls {
      display: flex;
      gap: 5px;
      align-items: center;
      margin-left: 10px; /* Small margin to separate from download/delete */
      flex-shrink: 0; /* Prevent shrinking */
  }

  .playlist-item-controls button {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1em;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s ease, transform 0.2s ease;
      padding: 5px;
      border-radius: 4px;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 30px;
      height: 30px;
  }

  .playlist-item-controls button:hover {
      opacity: 1;
      background-color: rgba(255, 255, 255, 0.15);
      transform: scale(1.05);
  }

  .playlist-item-controls .remove-from-playlist-btn {
      color: #ff6f61;
  }

  .playlist-item-controls .remove-from-playlist-btn:hover {
      background-color: rgba(255, 111, 97, 0.25);
  }

  .playlist-item-controls button:disabled {
    cursor: not-allowed;
    opacity: 0.3;
    transform: none;
  }


  /* Action Buttons & Inputs (General Styling) */
  .features-group input[type="url"],
  .features-group button,
  .library-filter-nav button { /* Added library filter buttons */
    width: 100%;
    padding: 10px;
    border: none;
    border-radius: 10px;
    background-color: var(--primary-color);
    color: white;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3); /* Button shadows */
  }

  .features-group input[type="url"] {
    background-color: var(--background-light);
    color: var(--text-color);
    font-weight: normal;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3); /* Inset shadow for inputs */
  }

  .features-group input[type="url"]::placeholder {
    color: #777;
  }

  .features-group input[type="url"]:focus {
    background-color: #3c3c3c;
    box-shadow: 0 0 0 2px var(--primary-color), inset 0 1px 3px rgba(0,0,0,0.3);
  }

  .features-group button:hover,
  .features-group button:focus,
  .library-filter-nav button:hover,
  .library-filter-nav button:focus { /* Added library filter buttons */
    background-color: #ff4433;
    outline: none;
    transform: translateY(-2px); /* Lift button on hover */
    box-shadow: 0 4px 10px rgba(0,0,0,0.4);
  }

  .features-group button:active,
  .library-filter-nav button:active { /* Added library filter buttons */
    transform: translateY(0); /* Press effect */
    box-shadow: 0 1px 3px rgba(0,0,0,0.4);
  }

  /* Library Browser Section */
  #library-browser {
    border-top: 1px solid var(--border-color);
    padding: 15px 20px;
    flex-grow: 1; /* Allows it to take available space within the tab */
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  #library-browser h3 {
    margin: 0;
    color: var(--primary-color);
    font-size: 1.1em;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    padding-bottom: 5px;
  }

  #library-filter-nav {
    display: flex;
    gap: 10px;
    flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
  }

  #library-filter-nav button {
    flex: 1; /* Distribute space evenly */
    min-width: 80px; /* Ensure buttons don't get too small */
    background-color: var(--background-light);
    color: var(--text-color);
    box-shadow: none; /* No shadow by default for these */
    font-weight: normal;
    transition: background-color 0.2s ease, color 0.2s ease;
  }

  #library-filter-nav button.active {
    background-color: var(--primary-color);
    color: white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    transform: none; /* No lift when active */
  }

  #library-filter-nav button:hover:not(.active) {
    background-color: #3c3c3c;
    transform: none;
    box-shadow: none;
  }

  #library-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 250px; /* Limit height if many items */
    overflow-y: auto;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background-color: var(--background-light);
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) #2a2a2a;
    flex-grow: 1; /* Take remaining space */
  }

  #library-list::-webkit-scrollbar {
    width: 8px;
  }

  #library-list::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 4px;
  }

  .library-list-item {
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s ease;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 1.1em;
  }
  .library-list-item:last-child {
    border-bottom: none;
  }
  .library-list-item:hover {
    background-color: #333;
  }
  .library-list-item span {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-grow: 1;
  }
  .library-list-item .count {
    color: var(--text-muted);
    font-size: 0.9em;
    margin-left: 10px;
    flex-shrink: 0;
  }


  /* Visualizer */
  #visualizer {
    width: 100%;
    height: 60px;
    background: #181818;
    border-top: 1px solid var(--border-color);
  }

  /* Settings Section */
  #settings-section {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
  }

  #lang-select,
  #theme-color-picker {
    flex-grow: 1;
    padding: 8px 12px; /* More padding */
    border-radius: 10px; /* More rounded */
    background: var(--background-light);
    border: none;
    color: var(--text-color);
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
  }

  #lang-select:hover,
  #lang-select:focus,
  #theme-color-picker:hover,
  #theme-color-picker:focus {
    background-color: #3c3c3c;
    outline: none;
    box-shadow: 0 0 0 2px var(--primary-color), inset 0 1px 3px rgba(0,0,0,0.3);
  }

  #theme-color-picker {
    width: 50px; /* Fixed width for color picker */
    height: 38px; /* Adjust height to match select */
    padding: 0;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    border: 1px solid var(--border-color); /* Add a border to picker */
    overflow: hidden; /* Hide default color input style */
  }

  #theme-color-picker::-webkit-color-swatch-wrapper {
      padding: 0;
  }
  #theme-color-picker::-webkit-color-swatch {
      border: none;
      border-radius: 8px; /* Match outer border radius */
  }
  #theme-color-picker::-moz-color-swatch,
  #theme-color-picker::-moz-focus-inner {
      border: none;
      border-radius: 8px;
  }


  /* Drag & Drop highlight */
  #player-container.dragover {
    border: 3px dashed var(--primary-color);
    box-shadow: 0 0 20px rgba(var(--primary-color-rgb), 0.5); /* Glowing border */
  }

  /* Media Queries for Responsiveness */
  @media (max-width: 400px) {
    body {
      padding: 10px;
    }
    #player-container {
      border-radius: 0; /* Full width on very small screens */
      height: 100vh; /* Fill screen height on mobile */
      width: 100%;
    }
    .features-group {
      padding: 10px 15px;
    }
    #playback-controls {
      gap: 10px;
      padding: 10px 15px;
    }
    #playback-controls button {
      width: 38px;
      height: 38px;
      font-size: 16px;
    }
    #play-pause-btn {
      width: 48px;
      height: 48px;
      font-size: 20px;
    }
    #search-input {
      width: calc(100% - 30px);
      margin: 10px 15px 0px 15px; /* Adjusted margin */
    }
    .playlist-item {
      padding: 8px 15px;
    }
    .playlist-item img {
      width: 32px;
      height: 32px;
    }
    .title-artist .title {
      font-size: 13px;
    }
    .title-artist .artist {
      font-size: 11px;
    }
    .download-btn, .delete-download-btn, .edit-info-btn, .playlist-item-controls button {
        font-size: 1em;
        width: 28px;
        height: 28px;
    }
    #current-song-info .title {
      font-size: 1.1em;
    }
    #current-song-info .artist {
      font-size: 0.8em;
    }
    #tab-navigation button {
        font-size: 1em;
        padding: 12px 0;
    }
    #library-browser {
      padding: 10px 15px;
      gap: 10px;
    }
    #library-filter-nav {
      gap: 5px;
    }
    #library-filter-nav button {
      padding: 8px;
      min-width: unset;
    }
    .library-list-item {
      padding: 10px 12px;
      font-size: 1em;
    }
  }

</style>
</head>
<body>
<div id="player-container" role="main" aria-label="Music Player" tabindex="0">

  <div id="player-header">
    <img id="cover-art" src="" alt="No track playing" />
    <div id="current-song-info">
      <div class="title" id="current-song-title"></div>
      <div class="artist" id="current-song-artist"></div>
    </div>
  </div>

  <div id="playback-controls" role="region" aria-label="Playback controls">
    <div id="progress-bar-container">
      <div id="progress-bar"></div>
    </div>
    <button id="prev-btn" aria-label="Previous track" tabindex="0">⏮</button>
    <button id="play-pause-btn" aria-label="Play/Pause" tabindex="0">▶️</button>
    <button id="next-btn" aria-label="Next track" tabindex="0">⏭</button>
    <button id="shuffle-btn" aria-pressed="false" aria-label="Shuffle toggle" tabindex="0">🔀</button>
    <button id="repeat-btn" aria-pressed="false" aria-label="Repeat toggle" tabindex="0">🔁</button>
  </div>

  <div id="tab-navigation" role="tablist" aria-label="Music Player Tabs">
    <button id="library-tab-btn" role="tab" aria-selected="true" aria-controls="library-tab-content" tabindex="0">Library</button>
    <button id="playlist-tab-btn" role="tab" aria-selected="false" aria-controls="playlist-tab-content" tabindex="-1">Playlist</button>
  </div>

  <div id="library-tab-content" class="tab-content active" role="tabpanel" aria-labelledby="library-tab-btn">
    <div id="library-browser">
      <h3>Browse Library</h3>
      <div id="library-filter-nav">
        <button id="view-all-songs-btn">All Songs</button>
        <button id="view-albums-btn">Albums</button>
        <button id="view-artists-btn">Artists</button>
        <button id="view-genres-btn">Genres</button>
      </div>
      <ul id="library-list">
        </ul>
    </div>

    <div id="stream-section" class="features-group">
      <h3>Stream Music</h3>
      <input id="stream-url-input" type="url" placeholder="Enter streaming URL (mp3/aac)" aria-label="Streaming URL" />
      <button id="play-stream-btn" aria-label="Play stream from URL">Play Stream</button>
    </div>

    <div id="file-management-section" class="features-group">
      <h3>File Management</h3>
      <button id="add-music-btn" aria-label="Add songs from device">Add Songs from Device</button>
      <input type="file" id="add-music-file-input" accept="audio/*" multiple hidden />

      <button id="export-playlist-btn" aria-label="Export playlist">Export Playlist</button>
      <button id="import-playlist-btn" aria-label="Import playlist">Import Playlist</button>
      <input type="file" id="import-file-input" accept=".json" hidden />
    </div>

    <div id="tools-section" class="features-group">
      <h3>Tools</h3>
      <button id="preload-all-btn" aria-label="Preload all music">Preload All Music</button>
      <button id="mp3-converter-btn" aria-label="Go to MP3 Converter">Go to MP3 Converter</button>
    </div>
  </div>

  <div id="playlist-tab-content" class="tab-content" role="tabpanel" aria-labelledby="playlist-tab-btn" style="display: none;">
    <div id="active-filter-display">
      <span id="current-filter-text"></span>
      <button id="clear-filter-btn">Clear Filter</button>
    </div>
    <input id="search-input" type="search" placeholder="Search songs..." aria-label="Search songs" />
    <ul id="playlist" role="list" tabindex="0" aria-label="Playlist"></ul>
  </div>

  <canvas id="visualizer" aria-hidden="true"></canvas>

  <div id="settings-section" class="features-group">
    <h3>Settings</h3>
    <select id="lang-select" aria-label="Select language">
      <option value="en" selected>English</option>
      <option value="es">Español</option>
      <option value="fr">Français</option>
      <option value="de">Deutsch</option>
    </select>
    <input type="color" id="theme-color-picker" value="#ff6f61" aria-label="Choose theme color" />
  </div>

</div>

<script>
(() => {
  // Localization strings
  const locales = {
    en: {
      searchPlaceholder: "Search songs...",
      streamPlaceholder: "Enter streaming URL (mp3/aac)",
      playStream: "Play Stream",
      addMusic: "Add Songs from Device",
      exportPlaylist: "Export Playlist",
      importPlaylist: "Import Playlist",
      noTrack: "No track playing",
      shuffle: "Shuffle toggle",
      repeat: "Repeat toggle",
      prevTrack: "Previous track",
      nextTrack: "Next track",
      playPause: "Play/Pause",
      playlist: "Playlist",
      selectLang: "Select language",
      fileNotSupported: "File type not supported. Use mp3, wav, ogg, aac.",
      importError: "Failed to import playlist.",
      noSongsInPlaylist: "No songs in playlist.",
      errorLoadingFile: "Error loading file:",
      downloadTrack: "Download track",
      deleteDownloadedTrack: "Delete downloaded track",
      downloadedAlert: "downloaded!",
      downloadFailedAlert: "Failed to download music. See console for details.",
      deleteDownloadedAlert: "deleted from downloads.",
      deleteFailedAlert: "Failed to delete music. See console for details.",
      mp3Converter: "Go to MP3 Converter",
      preloadAllMusic: "Preload All Music",
      preloadingAll: "Preloading all...",
      preloading: "Preloading",
      preloadComplete: "Preload complete!",
      of: "of",
      tracks: "tracks",
      failedToPreload: "failed to preload",
      noSongsInPlaylistToPreload: "No songs in playlist to preload.",
      autoplayBlocked: "Autoplay blocked. Please tap play or select a song.",
      // Headings
      libraryTab: "Library", // New
      playlistTab: "Playlist", // Existing
      streamMusicHeading: "Stream Music",
      fileManagementHeading: "File Management",
      toolsHeading: "Tools",
      settingsHeading: "Settings",
      // Library View
      browseLibraryHeading: "Browse Library",
      allSongs: "All Songs",
      albums: "Albums",
      artists: "Artists",
      genres: "Genres",
      editInfo: "Edit Info",
      clearFilter: "Clear Filter",
      filteringBy: "Filtering by:",
      unknownAlbum: "Unknown Album",
      unknownArtist: "Unknown Artist",
      unknownGenre: "Unknown Genre",
      promptTitle: "Enter Title:",
      promptArtist: "Enter Artist:",
      promptAlbum: "Enter Album:",
      promptGenre: "Enter Genre:",
      confirmEdit: "Track info updated!",
    },
    es: {
      searchPlaceholder: "Buscar canciones...",
      streamPlaceholder: "Introduce URL de streaming (mp3/aac)",
      playStream: "Reproducir Streaming",
      addMusic: "Añadir canciones del dispositivo",
      exportPlaylist: "Exportar Lista",
      importPlaylist: "Importar Lista",
      noTrack: "Ninguna canción reproducida",
      shuffle: "Alternar aleatorio",
      repeat: "Alternar repetición",
      prevTrack: "Pista anterior",
      nextTrack: "Siguiente pista",
      playPause: "Reproducir/Pausar",
      playlist: "Lista de reproducción",
      selectLang: "Seleccionar idioma",
      fileNotSupported: "Tipo de archivo no soportado. Usa mp3, wav, ogg, aac.",
      importError: "Error al importar la lista.",
      noSongsInPlaylist: "No hay canciones en la lista.",
      errorLoadingFile: "Error cargando archivo:",
      downloadTrack: "Descargar pista",
      deleteDownloadedTrack: "Eliminar pista descargada",
      downloadedAlert: "descargado!",
      downloadFailedAlert: "Fallo al descargar la música. Ver consola para detalles.",
      deleteDownloadedAlert: "eliminado de las descargas.",
      deleteFailedAlert: "Fallo al eliminar la música. Ver consola para detalles.",
      mp3Converter: "Ir al convertidor de MP3",
      preloadAllMusic: "Precargar toda la música",
      preloadingAll: "Precargando todo...",
      preloading: "Precargando",
      preloadComplete: "¡Precarga completa!",
      of: "de",
      tracks: "canciones",
      failedToPreload: "fallaron al precargar",
      noSongsInPlaylistToPreload: "No hay canciones en la lista para precargar.",
      autoplayBlocked: "Autoplay bloqueado. Toca reproducir o selecciona una canción.",
      // Headings
      libraryTab: "Biblioteca",
      playlistTab: "Lista de Reproducción",
      streamMusicHeading: "Reproducir Música",
      fileManagementHeading: "Gestión de Archivos",
      toolsHeading: "Herramientas",
      settingsHeading: "Configuración",
      // Library View
      browseLibraryHeading: "Explorar Biblioteca",
      allSongs: "Todas las Canciones",
      albums: "Álbumes",
      artists: "Artistas",
      genres: "Géneros",
      editInfo: "Editar Info",
      clearFilter: "Borrar Filtro",
      filteringBy: "Filtrando por:",
      unknownAlbum: "Álbum Desconocido",
      unknownArtist: "Artista Desconocido",
      unknownGenre: "Género Desconocido",
      promptTitle: "Introducir Título:",
      promptArtist: "Introducir Artista:",
      promptAlbum: "Introducir Álbum:",
      promptGenre: "Introducir Género:",
      confirmEdit: "¡Información de la pista actualizada!",
    },
    fr: {
      searchPlaceholder: "Rechercher des chansons...",
      streamPlaceholder: "Entrez l'URL de streaming (mp3/aac)",
      playStream: "Lire le flux",
      addMusic: "Ajouter des chansons depuis l'appareil",
      exportPlaylist: "Exporter la liste",
      importPlaylist: "Importer la liste",
      noTrack: "Aucune piste en cours",
      shuffle: "Activer le mode aléatoire",
      repeat: "Activer la répétition",
      prevTrack: "Piste precedente",
      nextTrack: "Piste suivante",
      playPause: "Lecture/Pause",
      playlist: "Liste de lecture",
      selectLang: "Choisir la langue",
      fileNotSupported: "Type de fichier non pris en charge. Utilisez mp3, wav, ogg, aac.",
      importError: "Échec de l'importation de la liste.",
      noSongsInPlaylist: "Aucune chanson dans la liste.",
      errorLoadingFile: "Erreur de chargement du fichier :",
      downloadTrack: "Télécharger la piste",
      deleteDownloadedTrack: "Supprimer la piste téléchargée",
      downloadedAlert: "téléchargé !",
      downloadFailedAlert: "Échec du téléchargement de la musique. Voir la console pour plus de détails.",
      deleteDownloadedAlert: "supprimé des téléchargements.",
      deleteFailedAlert: "Échec de la suppression de la musique. Voir la console pour plus de détails.",
      mp3Converter: "Aller au convertisseur MP3",
      preloadAllMusic: "Précharger toute la musique",
      preloadingAll: "Préchargement en cours...",
      preloading: "Préchargement",
      preloadComplete: "Préchargement terminé !",
      of: "de",
      tracks: "pistes",
      failedToPreload: "n'ont pas pu être préchargées",
      noSongsInPlaylistToPreload: "Aucune chanson dans la playlist à précharger.",
      autoplayBlocked: "Autoplay bloqué. Veuillez appuyer sur lecture ou sélectionner une chanson.",

      // Headings
      libraryTab: "Bibliothèque",
      playlistTab: "Liste de lecture",
      streamMusicHeading: "Diffuser de la musique",
      fileManagementHeading: "Gestion des fichiers",
      toolsHeading: "Outils",
      settingsHeading: "Paramètres",
      // Library View
      browseLibraryHeading: "Parcourir la bibliothèque",
      allSongs: "Toutes les chansons",
      albums: "Albums",
      artists: "Artistes",
      genres: "Genres",
      editInfo: "Modifier les infos",
      clearFilter: "Effacer le filtre",
      filteringBy: "Filtrage par :",
      unknownAlbum: "Album Inconnu",
      unknownArtist: "Artiste Inconnu",
      unknownGenre: "Genre Inconnu",
      promptTitle: "Entrez le titre :",
      promptArtist: "Entrez l'artiste :",
      promptAlbum: "Entrez l'album :",
      promptGenre: "Entrez le genre :",
      confirmEdit: "Informations de la piste mises à jour !",
    },
    de: {
      searchPlaceholder: "Songs suchen...",
      streamPlaceholder: "Streaming-URL eingeben (mp3/aac)",
      playStream: "Stream abspielen",
      addMusic: "Songs vom Gerät hinzufügen",
      exportPlaylist: "Playlist exportieren",
      importPlaylist: "Playlist importieren",
      noTrack: "Kein Titel läuft",
      shuffle: "Shuffle ein-/ausschalten",
      repeat: "Wiederholung ein-/ausschalten",
      prevTrack: "Vorheriger Titel",
      nextTrack: "Nächster Titel",
      playPause: "Abspielen/Pause",
      playlist: "Playlist",
      selectLang: "Sprache wählen",
      fileNotSupported: "Dateityp nicht unterstützt. Verwenden Sie mp3, wav, ogg, aac.",
      importError: "Import der Playlist fehlgeschlagen.",
      noSongsInPlaylist: "Keine Lieder in der Playlist.",
      errorLoadingFile: "Fehler beim Laden der Datei:",
      downloadTrack: "Titel herunterladen",
      deleteDownloadedTrack: "Heruntergeladenen Titel löschen",
      downloadedAlert: "heruntergeladen!",
      downloadFailedAlert: "Fehler beim Herunterladen der Musik. Details in der Konsole.",
      deleteDownloadedAlert: "aus Downloads gelöscht.",
      deleteFailedAlert: "Fehler beim Löschen der Musik. Details in der Konsole.",
      mp3Converter: "Zum MP3-Konverter",
      preloadAllMusic: "Alle Musik vorladen",
      preloadingAll: "Lade alles vor...",
      preloading: "Vorladen",
      preloadComplete: "Vorladen abgeschlossen!",
      of: "von",
      tracks: "Titel",
      failedToPreload: "konnten nicht vorgeladen werden",
      noSongsInPlaylistToPreload: "Keine Titel in der Playlist zum Vorladen.",
      autoplayBlocked: "Autoplay blockiert. Bitte auf Play tippen oder einen Song auswählen.",

      // Headings
      libraryTab: "Bibliothek",
      playlistTab: "Playlist",
      streamMusicHeading: "Musik streamen",
      fileManagementHeading: "Dateiverwaltung",
      toolsHeading: "Werkzeuge",
      settingsHeading: "Einstellungen",
      // Library View
      browseLibraryHeading: "Bibliothek durchsuchen",
      allSongs: "Alle Songs",
      albums: "Alben",
      artists: "Künstler",
      genres: "Genres",
      editInfo: "Info bearbeiten",
      clearFilter: "Filter löschen",
      filteringBy: "Filtern nach:",
      unknownAlbum: "Unbekanntes Album",
      unknownArtist: "Unbekannter Künstler",
      unknownGenre: "Unbekanntes Genre",
      promptTitle: "Titel eingeben:",
      promptArtist: "Künstler eingeben:",
      promptAlbum: "Album eingeben:",
      promptGenre: "Genre eingeben:",
      confirmEdit: "Titelinfo aktualisiert!",
    },
  };

  // Elements
  const container = document.getElementById('player-container');
  const coverArt = document.getElementById('cover-art');
  const playPauseBtn = document.getElementById('play-pause-btn');
  const prevBtn = document.getElementById('prev-btn');
  const nextBtn = document.getElementById('next-btn');
  const shuffleBtn = document.getElementById('shuffle-btn');
  const repeatBtn = document.getElementById('repeat-btn');
  const playlistEl = document.getElementById('playlist');
  const searchInput = document.getElementById('search-input');
  const streamUrlInput = document.getElementById('stream-url-input');
  const playStreamBtn = document.getElementById('play-stream-btn');
  const addMusicBtn = document.getElementById('add-music-btn');
  const addMusicFileInput = document.getElementById('add-music-file-input');
  const exportPlaylistBtn = document.getElementById('export-playlist-btn');
  const importPlaylistBtn = document.getElementById('import-playlist-btn');
  const importFileInput = document.getElementById('import-file-input');
  const visualizerCanvas = document.getElementById('visualizer');
  const langSelect = document.getElementById('lang-select');
  const themeColorPicker = document.getElementById('theme-color-picker');
  const mp3ConverterBtn = document.getElementById('mp3-converter-btn');
  const preloadAllBtn = document.getElementById('preload-all-btn');

  const currentSongTitleEl = document.getElementById('current-song-title');
  const currentSongArtistEl = document.getElementById('current-song-artist');
  const progressBarContainer = document.getElementById('progress-bar-container');
  const progressBar = document.getElementById('progress-bar');

  // New Tab Elements
  const libraryTabBtn = document.getElementById('library-tab-btn'); // Renamed
  const playlistTabBtn = document.getElementById('playlist-tab-btn');
  const libraryTabContent = document.getElementById('library-tab-content'); // Renamed
  const playlistTabContent = document.getElementById('playlist-tab-content');

  // New Library Browse Elements
  const browseLibraryHeading = document.querySelector('#library-browser h3');
  const viewAllSongsBtn = document.getElementById('view-all-songs-btn');
  const viewAlbumsBtn = document.getElementById('view-albums-btn');
  const viewArtistsBtn = document.getElementById('view-artists-btn');
  const viewGenresBtn = document.getElementById('view-genres-btn');
  const libraryListEl = document.getElementById('library-list');
  const activeFilterDisplay = document.getElementById('active-filter-display');
  const currentFilterText = document.getElementById('current-filter-text');
  const clearFilterBtn = document.getElementById('clear-filter-btn');


  // Heading elements (now nested differently)
  const streamMusicHeading = libraryTabContent.querySelector('#stream-section h3');
  const fileManagementHeading = libraryTabContent.querySelector('#file-management-section h3');
  const toolsHeading = libraryTabContent.querySelector('#tools-section h3');
  const settingsHeading = document.querySelector('#settings-section h3');


  let locale = locales.en;

  // Audio & state
  const audio = new Audio();
  let playlist = []; // This will be loaded from localStorage
  let filteredPlaylist = []; // For search results within the playlist tab
  let currentIndex = -1;
  let isPlaying = false;
  let shuffle = false;
  let repeat = false;

  // New: Filter for library/playlist views
  let currentFilter = {
    type: 'all', // 'all', 'album', 'artist', 'genre'
    value: null // The specific album name, artist name, or genre name
  };

  // Audio context for visualization
  let audioCtx, analyser, source, dataArray, animationId;

  // IndexedDB Constants
  const IDB_DATABASE_NAME = 'music-db';
  const IDB_STORE_NAME = 'tracks';
  const LOCAL_STORAGE_PLAYLIST_KEY = 'musicPlayerPlaylist'; // Key for localStorage

  // Helper: default cover art SVG as base64 data URI
  const defaultCoverArt = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAMDUwIDUwIiBmaWxsPSIjNjY2NjY2IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSIyNSIgY3k9IjI1IiByPSIyMCIgZmlsbD0iI2NjY2NjY2MiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYgNiIiIHN0cm9rZT0iIzQwNDA0MCIgc3Ryb2tlLXdpZHRoPSI1Ii8+CjxwYXRoIGQ9Ik0yNSAxNWw2IDYtNiA2bTAgMTBsNiA2bS02LTYtNiA2IiBmaWxsPSIjNzc3ZjdmIi8+CjwvYXN2Zz4=`;

  // Set default UI text based on locale
  function updateLocaleTexts() {
    searchInput.placeholder = locale.searchPlaceholder;
    streamUrlInput.placeholder = locale.streamPlaceholder;
    playStreamBtn.textContent = locale.playStream;
    addMusicBtn.textContent = locale.addMusic;
    exportPlaylistBtn.textContent = locale.exportPlaylist;
    importPlaylistBtn.textContent = locale.importPlaylist;
    playPauseBtn.setAttribute('aria-label', locale.playPause);
    prevBtn.setAttribute('aria-label', locale.prevTrack);
    nextBtn.setAttribute('aria-label', locale.nextTrack);
    shuffleBtn.setAttribute('aria-label', locale.shuffle);
    repeatBtn.setAttribute('aria-label', locale.repeat);
    playlistEl.setAttribute('aria-label', locale.playlist);
    langSelect.setAttribute('aria-label', locale.selectLang);
    mp3ConverterBtn.textContent = locale.mp3Converter;
    preloadAllBtn.textContent = locale.preloadAllMusic;

    // Update section headings
    libraryTabBtn.textContent = locale.libraryTab; // Renamed
    playlistTabBtn.textContent = locale.playlistTab;
    streamMusicHeading.textContent = locale.streamMusicHeading;
    fileManagementHeading.textContent = locale.fileManagementHeading;
    toolsHeading.textContent = locale.toolsHeading;
    settingsHeading.textContent = locale.settingsHeading;

    // Library Browser Headings/Buttons
    browseLibraryHeading.textContent = locale.browseLibraryHeading;
    viewAllSongsBtn.textContent = locale.allSongs;
    viewAlbumsBtn.textContent = locale.albums;
    viewArtistsBtn.textContent = locale.artists;
    viewGenresBtn.textContent = locale.genres;
    clearFilterBtn.textContent = locale.clearFilter;

    if(currentIndex === -1) {
        coverArt.alt = locale.noTrack;
        currentSongTitleEl.textContent = locale.noTrack;
        currentSongArtistEl.textContent = '';
    }
  }

  updateLocaleTexts();

  // Utilities
  function isSupportedFileType(fileName) {
    return /\.(mp3|wav|ogg|aac)$/i.test(fileName);
  }

  // Extract basic metadata from file or URL (title from filename)
  // For simplicity, no ID3 parsing, just filename for title
  function createTrackObject(fileOrUrl) {
    let title = '', artist = '', album = locale.unknownAlbum, genre = locale.unknownGenre, url = '', cover = defaultCoverArt;
    if(typeof fileOrUrl === 'string') {
      // Streaming URL
      url = fileOrUrl;
      title = url.split('/').pop().split('?')[0] || 'Streaming Track';
      artist = '';
    } else {
      // File object
      url = URL.createObjectURL(fileOrUrl);
      title = fileOrUrl.name.replace(/\.[^/.]+$/, "");
      artist = ''; // Can't easily get from file name
    }
    // Add new properties for download feature
    // A unique ID is crucial for IndexedDB and editing
    const id = Date.now().toString(36) + Math.random().toString(36).substring(2, 7);
    return {id, title, artist, album, genre, url, cover, isDownloaded: false, offlineUrl: null};
  }

  // Helper to open IndexedDB
  async function openIndexedDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(IDB_DATABASE_NAME, 1); // Version 1

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(IDB_STORE_NAME)) {
          db.createObjectStore(IDB_STORE_NAME, { keyPath: 'id' });
        }
      };

      request.onsuccess = (event) => {
        resolve(event.target.result);
      };

      request.onerror = (event) => {
        console.error('IndexedDB error:', event.target.error);
        reject(event.target.error);
      };
    });
  }

  // Function to download and store a track
  async function downloadAndStoreTrack(track) {
    if (!track || !track.url || !track.id) {
      console.error('Invalid track object for download:', track);
      return false;
    }
    if (track.isDownloaded) {
        console.log(`Track "${track.title}" is already downloaded.`);
        return true;
    }

    try {
      const db = await openIndexedDB();
      const response = await fetch(track.url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const audioBlob = await response.blob();
      const mimeType = response.headers.get('Content-Type') || 'audio/mpeg';

      const transaction = db.transaction([IDB_STORE_NAME], 'readwrite');
      const store = transaction.objectStore(IDB_STORE_NAME);

      await store.add({
        id: track.id, // Use the track's existing ID
        title: track.title,
        artist: track.artist,
        album: track.album,
        genre: track.genre,
        originalUrl: track.url,
        audioBlob: audioBlob,
        mimeType: mimeType,
        cover: track.cover || defaultCoverArt,
      });

      const originalTrackIndex = playlist.findIndex(t => t.id === track.id);
      if (originalTrackIndex !== -1) {
        playlist[originalTrackIndex].offlineUrl = `indexeddb://${track.id}`;
        playlist[originalTrackIndex].isDownloaded = true;
        renderPlaylist();
        savePlaylist(); // Save playlist after download status changes
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error downloading and storing track:', error);
      alert(`${locale.downloadFailedAlert}`);
      return false;
    }
  }

  // Function to delete a track from IndexedDB
  async function deleteStoredTrack(track) {
      if (!track || !track.offlineUrl) return false;

      const urlObj = new URL(track.offlineUrl);
      if (urlObj.protocol !== 'indexeddb:') {
          console.warn('Track is not an IndexedDB URL, cannot delete:', track.offlineUrl);
          return false;
      }
      const trackId = urlObj.hostname;

      try {
          const db = await openIndexedDB();
          const transaction = db.transaction([IDB_STORE_NAME], 'readwrite');
          const store = transaction.objectStore(IDB_STORE_NAME);

          await store.delete(trackId);

          const originalTrackIndex = playlist.findIndex(t => t.id === track.id);
          if (originalTrackIndex !== -1) {
              delete playlist[originalTrackIndex].offlineUrl;
              playlist[originalTrackIndex].isDownloaded = false;
              renderPlaylist();
              savePlaylist(); // Save playlist after download status changes
              return true;
          }
          return false;
      } catch (error) {
          console.error('Error deleting track from IndexedDB:', error);
          alert(`${locale.deleteFailedAlert}`);
          return false;
      }
  }

  // Function to check if a track is downloaded
  async function isTrackDownloaded(track) {
    if (!track || !track.id) return false;

    try {
      const db = await openIndexedDB();
      const transaction = db.transaction([IDB_STORE_NAME], 'readonly');
      const store = transaction.objectStore(IDB_STORE_NAME);
      
      return new Promise((resolve) => {
        const request = store.get(track.id); // Get directly by ID
        request.onsuccess = (event) => {
          if (event.target.result) {
            track.offlineUrl = `indexeddb://${event.target.result.id}`;
            track.isDownloaded = true;
            resolve(true);
          } else {
            resolve(false);
          }
        };
        request.onerror = () => {
          console.error("Error checking download status:", event.target.error);
          resolve(false);
        };
      });
    } catch (error) {
        console.error("Could not open IndexedDB to check download status:", error);
        return false;
    }
  }

  // Populate playlist with tracks and update download status
  async function checkAllTracksDownloadStatus() {
    for (const track of playlist) {
      await isTrackDownloaded(track);
    }
    renderPlaylist(); // Render after checking all statuses
    renderLibraryList(currentFilter.type); // Also render library list
  }

  // Function to preload all tracks in the playlist
  async function preloadAllMusic() {
    if (playlist.length === 0) {
        alert(locale.noSongsInPlaylistToPreload);
        return;
    }

    preloadAllBtn.disabled = true;
    preloadAllBtn.textContent = locale.preloadingAll;

    let downloadedCount = 0;
    let failedCount = 0;

    for (const track of playlist) {
        if (track.isDownloaded) {
            downloadedCount++;
            continue;
        }

        const success = await downloadAndStoreTrack(track);
        if (success) {
            downloadedCount++;
        } else {
            failedCount++;
        }
        preloadAllBtn.textContent = `${locale.preloading} (${downloadedCount}/${playlist.length})`;
    }

    preloadAllBtn.disabled = false;
    preloadAllBtn.textContent = locale.preloadAllMusic;

    let message = `${locale.preloadComplete} ${downloadedCount} ${locale.of} ${playlist.length} ${locale.tracks}.`;
    if (failedCount > 0) {
        message += ` ${failedCount} ${locale.failedToPreload}.`;
    }
    alert(message);
  }

  // --- Playlist Persistence (LocalStorage) ---

  // Save playlist to LocalStorage
  function savePlaylist() {
    try {
      // We only save the necessary properties to keep the JSON size down
      // Now including ID for persistence and album/genre
      const simplePlaylist = playlist.map(track => ({
        id: track.id,
        title: track.title,
        artist: track.artist,
        album: track.album, // Save album
        genre: track.genre, // Save genre
        url: track.url,
        cover: track.cover
      }));
      localStorage.setItem(LOCAL_STORAGE_PLAYLIST_KEY, JSON.stringify(simplePlaylist));
      console.log('Playlist saved to LocalStorage.');
    } catch (e) {
      console.error('Error saving playlist to LocalStorage:', e);
    }
  }

  // Load playlist from LocalStorage
  function loadPlaylist() {
    try {
      const storedPlaylist = localStorage.getItem(LOCAL_STORAGE_PLAYLIST_KEY);
      if (storedPlaylist) {
        const loadedTracks = JSON.parse(storedPlaylist);
        // Reconstruct the full track object, ensuring isDownloaded/offlineUrl are correctly re-evaluated
        playlist = loadedTracks.map(t => ({
            id: t.id || (Date.now().toString(36) + Math.random().toString(36).substring(2, 7)), // Ensure ID
            title: t.title || 'Unknown Title',
            artist: t.artist || 'Unknown Artist',
            album: t.album || locale.unknownAlbum, // Load album
            genre: t.genre || locale.unknownGenre, // Load genre
            url: t.url,
            cover: t.cover || defaultCoverArt,
            isDownloaded: false, // Will be updated by checkAllTracksDownloadStatus
            offlineUrl: null     // Will be updated by checkAllTracksDownloadStatus
        }));
        console.log('Playlist loaded from LocalStorage.');
      } else {
        playlist = []; // Start with an empty playlist if nothing saved
        console.log('No playlist found in LocalStorage.');
      }
    } catch (e) {
      console.error('Error loading playlist from LocalStorage:', e);
      playlist = []; // Fallback to empty playlist on error
    }
  }


  // Render playlist items filtered by searchInput.value AND currentFilter
  function renderPlaylist() {
    playlistEl.innerHTML = '';

    const searchTerm = searchInput.value.trim().toLowerCase();

    // First, filter by currentLibraryFilter
    let temporarilyFilteredPlaylist = playlist;

    if (currentFilter.type !== 'all' && currentFilter.value !== null) {
      temporarilyFilteredPlaylist = playlist.filter(track => {
        if (currentFilter.type === 'album') return track.album.toLowerCase() === currentFilter.value.toLowerCase();
        if (currentFilter.type === 'artist') return track.artist.toLowerCase() === currentFilter.value.toLowerCase();
        if (currentFilter.type === 'genre') return track.genre.toLowerCase() === currentFilter.value.toLowerCase();
        return true; // Should not happen if type is not 'all'
      });
    }

    // Then, apply search filter on the already filtered list
    filteredPlaylist = temporarilyFilteredPlaylist.filter(track => {
      return (
        track.title.toLowerCase().includes(searchTerm) ||
        track.artist.toLowerCase().includes(searchTerm) ||
        track.album.toLowerCase().includes(searchTerm) || // Include album in search
        track.genre.toLowerCase().includes(searchTerm)    // Include genre in search
      );
    });

    // Update filter display
    if (currentFilter.type !== 'all') {
      activeFilterDisplay.classList.add('active');
      currentFilterText.textContent = `${locale.filteringBy} ${currentFilter.value} (${currentFilter.type})`;
    } else {
      activeFilterDisplay.classList.remove('active');
      currentFilterText.textContent = '';
    }


    if(filteredPlaylist.length === 0) {
      const emptyMsg = document.createElement('li');
      emptyMsg.textContent = locale.noSongsInPlaylist;
      emptyMsg.style.padding = '10px 20px';
      emptyMsg.style.color = '#777';
      emptyMsg.style.textAlign = 'center'; /* Center the message */
      playlistEl.appendChild(emptyMsg);
      return;
    }

    filteredPlaylist.forEach((track, idx) => { // Original 'idx' here is the index in filteredPlaylist
        const originalIndex = playlist.indexOf(track); // Get the actual index in the main playlist

        const item = document.createElement('li');
        item.className = 'playlist-item';
        item.tabIndex = 0;
        item.dataset.originalIdx = originalIndex; // Store original index for operations
        item.dataset.trackId = track.id; // Store unique ID for direct lookup

        if(originalIndex === currentIndex) {
            item.classList.add('active');
        }

        const img = document.createElement('img');
        img.src = track.cover || defaultCoverArt;
        img.alt = "";

        const titleArtist = document.createElement('div');
        titleArtist.className = 'title-artist';

        const titleEl = document.createElement('div');
        titleEl.className = 'title';
        titleEl.textContent = track.title;

        const artistEl = document.createElement('div');
        artistEl.className = 'artist';
        // Display artist and album
        artistEl.textContent = track.artist + (track.album && track.album !== locale.unknownAlbum ? ` / ${track.album}` : '');

        titleArtist.appendChild(titleEl);
        titleArtist.appendChild(artistEl);

        item.appendChild(img);
        item.appendChild(titleArtist);

        // --- Existing Download/Delete Buttons ---
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'download-btn';
        downloadBtn.setAttribute('aria-label', locale.downloadTrack);
        downloadBtn.textContent = '⬇️';
        downloadBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            downloadBtn.disabled = true;
            downloadBtn.textContent = '⏳';
            const success = await downloadAndStoreTrack(track);
            if (success) {
                alert(`"${track.title}" ${locale.downloadedAlert}`);
            }
            downloadBtn.disabled = false;
            renderPlaylist(); // Re-render to update button state
        });
        item.appendChild(downloadBtn);

        const deleteDownloadBtn = document.createElement('button'); // Renamed for clarity
        deleteDownloadBtn.className = 'delete-download-btn';
        deleteDownloadBtn.setAttribute('aria-label', locale.deleteDownloadedTrack);
        deleteDownloadBtn.textContent = '🗑️';
        deleteDownloadBtn.style.display = 'none';
        deleteDownloadBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            deleteDownloadBtn.disabled = true;
            const success = await deleteStoredTrack(track);
            if (success) {
                alert(`"${track.title}" ${locale.deleteDownloadedAlert}`);
            }
            deleteDownloadBtn.disabled = false;
            renderPlaylist(); // Re-render to update button state
        });
        item.appendChild(deleteDownloadBtn);

        if (track.isDownloaded) {
            downloadBtn.style.display = 'none';
            deleteDownloadBtn.style.display = 'block';
        } else {
            downloadBtn.style.display = 'block';
            deleteDownloadBtn.style.display = 'none';
        }

        // --- NEW Playlist Management Buttons & Edit Info ---
        const playlistItemControls = document.createElement('div');
        playlistItemControls.className = 'playlist-item-controls';

        // Edit Info Button
        const editInfoBtn = document.createElement('button');
        editInfoBtn.className = 'edit-info-btn';
        editInfoBtn.setAttribute('aria-label', locale.editInfo);
        editInfoBtn.textContent = '✏️';
        editInfoBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            editTrackInfo(track.id);
        });
        playlistItemControls.appendChild(editInfoBtn);

        const moveUpBtn = document.createElement('button');
        moveUpBtn.className = 'move-up-btn';
        moveUpBtn.setAttribute('aria-label', 'Move track up');
        moveUpBtn.textContent = '⬆️';
        if (originalIndex === 0) { // Disable if already at the top
            moveUpBtn.disabled = true;
            moveUpBtn.style.opacity = 0.3;
            moveUpBtn.style.cursor = 'not-allowed';
        }
        moveUpBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent playing the song
            moveTrackInPlaylist(originalIndex, originalIndex - 1);
        });
        playlistItemControls.appendChild(moveUpBtn);

        const moveDownBtn = document.createElement('button');
        moveDownBtn.className = 'move-down-btn';
        moveDownBtn.setAttribute('aria-label', 'Move track down');
        moveDownBtn.textContent = '⬇️';
        if (originalIndex === playlist.length - 1) { // Disable if already at the bottom
            moveDownBtn.disabled = true;
            moveDownBtn.style.opacity = 0.3;
            moveDownBtn.style.cursor = 'not-allowed';
        }
        moveDownBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent playing the song
            moveTrackInPlaylist(originalIndex, originalIndex + 1);
        });
        playlistItemControls.appendChild(moveDownBtn);

        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-from-playlist-btn';
        removeBtn.setAttribute('aria-label', 'Remove track from playlist');
        removeBtn.textContent = '✖️';
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent playing the song
            removeTrackFromPlaylist(originalIndex);
        });
        playlistItemControls.appendChild(removeBtn);

        item.appendChild(playlistItemControls); // Add the controls container to the item

        // --- Existing Play/Keyboard Event Listeners ---
        item.addEventListener('click', () => {
            const urlToPlay = track.isDownloaded ? track.offlineUrl : track.url;
            playTrack(originalIndex, urlToPlay); // Use originalIndex for playing
        });
        item.addEventListener('keydown', (e) => {
            if(e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                const urlToPlay = track.isDownloaded ? track.offlineUrl : track.url;
                playTrack(originalIndex, urlToPlay); // Use originalIndex for playing
            }
        });

        playlistEl.appendChild(item);
    });
  }

  // Load & play a track by index
  function playTrack(idx, urlToPlay = null) {
    if(idx < 0 || idx >= playlist.length) return;

    currentIndex = idx;
    const track = playlist[currentIndex];
    audio.src = urlToPlay || track.url;

    // Update current song info display
    currentSongTitleEl.textContent = track.title;
    currentSongArtistEl.textContent = track.artist;
    coverArt.alt = `Cover art for ${track.title} by ${track.artist}`;


    audio.play()
      .then(() => {
        isPlaying = true;
        updatePlayPauseButton();
        updateCoverArt(track.cover);
        updatePlaylistActive();
      })
      .catch((error) => {
        isPlaying = false; // Ensure UI reflects paused state
        updatePlayPauseButton();
        console.error("Audio playback failed:", error);
        // More specific error message for autoplay
        if (error.name === 'NotAllowedError' || error.name === 'AbortError') {
          alert(locale.autoplayBlocked);
        } else {
          alert("Failed to play track. Make sure your browser allows autoplay or try interacting with the page first.");
        }
      });
  }

  // Play next track
  function playNext() {
    if(playlist.length === 0) return;

    // Filtered playlist for playback logic (if a filter is active)
    let playablePlaylist = playlist;
    if (currentFilter.type !== 'all' && currentFilter.value !== null) {
      playablePlaylist = playlist.filter(track => {
        if (currentFilter.type === 'album') return track.album.toLowerCase() === currentFilter.value.toLowerCase();
        if (currentFilter.type === 'artist') return track.artist.toLowerCase() === currentFilter.value.toLowerCase();
        if (currentFilter.type === 'genre') return track.genre.toLowerCase() === currentFilter.value.toLowerCase();
        return true;
      });
    }

    if (playablePlaylist.length === 0) { // No songs in filtered view
        pauseAudio();
        return;
    }

    let nextOriginalIndex = -1; // Index in the main `playlist` array

    if(shuffle) {
      let nextFilteredIdx;
      do {
        nextFilteredIdx = Math.floor(Math.random() * playablePlaylist.length);
        nextOriginalIndex = playlist.indexOf(playablePlaylist[nextFilteredIdx]);
      } while (nextOriginalIndex === currentIndex && playablePlaylist.length > 1);
      playTrack(nextOriginalIndex, playablePlaylist[nextFilteredIdx].isDownloaded ? playablePlaylist[nextFilteredIdx].offlineUrl : playablePlaylist[nextFilteredIdx].url);
    } else {
      // Find current track's index in the *filtered* playlist
      const currentFilteredIdx = playablePlaylist.findIndex(track => playlist[currentIndex] && track.id === playlist[currentIndex].id);

      if (currentFilteredIdx === -1) { // Current track not in filtered list, start from beginning of filtered list
          nextOriginalIndex = playlist.indexOf(playablePlaylist[0]);
      } else if (currentFilteredIdx + 1 < playablePlaylist.length) {
          nextOriginalIndex = playlist.indexOf(playablePlaylist[currentFilteredIdx + 1]);
      } else if (repeat) {
          nextOriginalIndex = playlist.indexOf(playablePlaylist[0]);
      } else {
          pauseAudio();
          return;
      }

      if (nextOriginalIndex !== -1) {
          playTrack(nextOriginalIndex, playlist[nextOriginalIndex].isDownloaded ? playlist[nextOriginalIndex].offlineUrl : playlist[nextOriginalIndex].url);
      } else {
          pauseAudio(); // Should not happen with above logic, but as a fallback
      }
    }
  }

  // Play previous track
  function playPrev() {
    if(playlist.length === 0) return;

    // Filtered playlist for playback logic (if a filter is active)
    let playablePlaylist = playlist;
    if (currentFilter.type !== 'all' && currentFilter.value !== null) {
      playablePlaylist = playlist.filter(track => {
        if (currentFilter.type === 'album') return track.album.toLowerCase() === currentFilter.value.toLowerCase();
        if (currentFilter.type === 'artist') return track.artist.toLowerCase() === currentFilter.value.toLowerCase();
        if (currentFilter.type === 'genre') return track.genre.toLowerCase() === currentFilter.value.toLowerCase();
        return true;
      });
    }

    if (playablePlaylist.length === 0) {
        pauseAudio();
        return;
    }

    let prevOriginalIndex = -1; // Index in the main `playlist` array

    if(shuffle) {
      let prevFilteredIdx;
      do {
        prevFilteredIdx = Math.floor(Math.random() * playablePlaylist.length);
        prevOriginalIndex = playlist.indexOf(playablePlaylist[prevFilteredIdx]);
      } while (prevOriginalIndex === currentIndex && playablePlaylist.length > 1);
      playTrack(prevOriginalIndex, playablePlaylist[prevFilteredIdx].isDownloaded ? playablePlaylist[prevFilteredIdx].offlineUrl : playablePlaylist[prevFilteredIdx].url);
    } else {
      const currentFilteredIdx = playablePlaylist.findIndex(track => playlist[currentIndex] && track.id === playlist[currentIndex].id);

      if (currentFilteredIdx === -1) { // Current track not in filtered list, go to last of filtered
          prevOriginalIndex = playlist.indexOf(playablePlaylist[playablePlaylist.length - 1]);
      } else if (currentFilteredIdx > 0) {
          prevOriginalIndex = playlist.indexOf(playablePlaylist[currentFilteredIdx - 1]);
      } else if (repeat) {
          prevOriginalIndex = playlist.indexOf(playablePlaylist[playablePlaylist.length - 1]);
      } else {
          pauseAudio();
          return;
      }

      if (prevOriginalIndex !== -1) {
          playTrack(prevOriginalIndex, playlist[prevOriginalIndex].isDownloaded ? playlist[prevOriginalIndex].offlineUrl : playlist[prevOriginalIndex].url);
      } else {
          pauseAudio();
      }
    }
  }

  // Toggle play/pause
  function togglePlayPause() {
    if(isPlaying) {
      pauseAudio();
    } else {
      if(currentIndex === -1 && playlist.length > 0) {
        // If no song is selected, try to play the first one from the potentially filtered list
        let trackToPlay = filteredPlaylist.length > 0 ? filteredPlaylist[0] : playlist[0];
        playTrack(playlist.indexOf(trackToPlay), trackToPlay.isDownloaded ? trackToPlay.offlineUrl : trackToPlay.url);
      } else if (currentIndex !== -1) {
        // If a song is selected, try to resume it
        const track = playlist[currentIndex];
        playTrack(currentIndex, track.isDownloaded ? track.offlineUrl : track.url);
      } else {
          console.log("No tracks available to play.");
      }
    }
  }

  function pauseAudio() {
    audio.pause();
    isPlaying = false;
    updatePlayPauseButton();
  }

  // Update UI play/pause icon
  function updatePlayPauseButton() {
    playPauseBtn.textContent = isPlaying ? "⏸" : "▶️";
  }

  // Update cover art
  function updateCoverArt(url) {
    coverArt.src = url || defaultCoverArt;
    // Alt text is handled in playTrack for now, but can be updated here for consistency
  }

  // Update active playlist item highlight
  function updatePlaylistActive() {
    const items = playlistEl.querySelectorAll('.playlist-item');
    items.forEach(item => {
      item.classList.remove('active');
      if(parseInt(item.dataset.originalIdx, 10) === currentIndex) { // Use originalIdx here
        item.classList.add('active');
        item.scrollIntoView({behavior: 'smooth', block: 'nearest'});
      }
    });
  }

  // Shuffle toggle
  function toggleShuffle() {
    shuffle = !shuffle;
    shuffleBtn.setAttribute('aria-pressed', shuffle);
    shuffleBtn.style.color = shuffle ? 'var(--primary-color)' : '';
  }

  // Repeat toggle
  function toggleRepeat() {
    repeat = !repeat;
    repeatBtn.setAttribute('aria-pressed', repeat);
    repeatBtn.style.color = repeat ? 'var(--primary-color)' : '';
  }

  // Play streaming URL
  function playStream() {
    const url = streamUrlInput.value.trim();
    if(!url) return;
    // Call playTrack with the streaming URL as a new track object
    const streamTrack = createTrackObject(url);
    // Add stream track to playlist if not already there, or play if it is
    const existingIndex = playlist.findIndex(t => t.url === url);
    if (existingIndex === -1) {
        playlist.push(streamTrack);
        savePlaylist(); // Save playlist after adding stream track
        playTrack(playlist.length - 1, streamTrack.url); // Pass URL explicitly
    } else {
        playTrack(existingIndex, playlist[existingIndex].url); // Pass URL explicitly
    }
    showTab('playlist-tab'); // Switch to playlist tab after playing stream
  }

  // Export playlist to JSON file
  function exportPlaylist() {
    if(playlist.length === 0) {
      alert(locale.noSongsInPlaylist);
      return;
    }
    const exportablePlaylist = playlist.map(track => ({
      id: track.id,
      title: track.title,
      artist: track.artist,
      album: track.album,
      genre: track.genre,
      url: track.url,
      cover: track.cover,
      // Do not export isDownloaded and offlineUrl as they are runtime/local cache specific
    }));

    const json = JSON.stringify(exportablePlaylist, null, 2);
    const blob = new Blob([json], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "playlist.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // Import playlist from JSON file
  function importPlaylistFromFile(file) {
    if(!file) return;
    const reader = new FileReader();
    reader.onload = async e => {
      try {
        const imported = JSON.parse(e.target.result);
        if(Array.isArray(imported)) {
          // Clear existing playlist and add imported tracks
          playlist = imported.map(t => ({
              id: t.id || (Date.now().toString(36) + Math.random().toString(36).substring(2, 7)), // Ensure ID
              title: t.title || 'Unknown Title',
              artist: t.artist || 'Unknown Artist',
              album: t.album || locale.unknownAlbum,
              genre: t.genre || locale.unknownGenre,
              url: t.url,
              cover: t.cover || defaultCoverArt,
              isDownloaded: false, // Reset download status for imported tracks
              offlineUrl: null,    // Reset offline URL
          })).filter(t => t.url); // Ensure tracks have a URL

          currentIndex = -1; // Reset current playing track
          isPlaying = false;
          audio.pause();
          audio.src = "";
          updateCoverArt(defaultCoverArt);
          savePlaylist(); // Save imported playlist
          await checkAllTracksDownloadStatus(); // Check download status for imported tracks
          updatePlayPauseButton();
          currentSongTitleEl.textContent = locale.noTrack; // Reset current song info
          currentSongArtistEl.textContent = '';
          progressBar.style.width = '0%'; // Reset progress bar
          showTab('playlist-tab'); // Switch to playlist tab after importing
          renderLibraryList(currentFilter.type); // Update library list
        } else {
          alert(locale.importError);
        }
      } catch (error) {
        console.error("Import playlist error:", error);
        alert(locale.importError);
      }
    };
    reader.readAsText(file);
  }

  // Handle files selected via input[type="file"] or drag-and-drop
  function handleFilesFromInput(files) {
    const accepted = Array.from(files).filter(f => isSupportedFileType(f.name));
    if (accepted.length === 0) {
      alert(locale.fileNotSupported);
      return;
    }
    accepted.forEach(file => {
      const track = createTrackObject(file);
      // Prevent duplicates based on URL (important for local files too)
      if (!playlist.some(t => t.url === track.url)) {
        playlist.push(track);
      }
    });
    savePlaylist(); // Save playlist after adding new files
    checkAllTracksDownloadStatus(); // Re-render and check download status after adding new files
    showTab('playlist-tab'); // Switch to playlist tab after adding songs
    renderLibraryList(currentFilter.type); // Update library list
  }

  // Drag & drop handlers for files
  function onDragOver(e) {
    e.preventDefault();
    container.classList.add('dragover');
  }
  function onDragLeave(e) {
    e.preventDefault();
    container.classList.remove('dragover');
  }
  function onDrop(e) {
    e.preventDefault();
    container.classList.remove('dragover');
    handleFilesFromInput(e.dataTransfer.files); // Use the unified file handling
  }

  // Keyboard shortcuts
  function onKeyDown(e) {
    // Only apply shortcuts if focus is not on an input/select
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

    switch(e.key.toLowerCase()) {
      case ' ':
        e.preventDefault();
        togglePlayPause();
        break;
      case 'arrowright':
        e.preventDefault();
        playNext();
        break;
      case 'arrowleft':
        e.preventDefault();
        playPrev();
        break;
      case 's':
        e.preventDefault();
        toggleShuffle();
        break;
      case 'r':
        e.preventDefault();
        toggleRepeat();
        break;
    }
  }

  // Visualizer setup
  function setupVisualizer() {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)(); // Use webkitAudioContext for broader compatibility
      analyser = audioCtx.createAnalyser();
      source = audioCtx.createMediaElementSource(audio);
      source.connect(analyser);
      analyser.connect(audioCtx.destination);
      analyser.fftSize = 256;
      const bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array(bufferLength);

      const canvasCtx = visualizerCanvas.getContext('2d');
      // Set canvas dimensions dynamically based on client size
      const WIDTH = visualizerCanvas.width = visualizerCanvas.clientWidth;
      const HEIGHT = visualizerCanvas.height = visualizerCanvas.clientHeight;

      function draw() {
        animationId = requestAnimationFrame(draw);
        analyser.getByteFrequencyData(dataArray);

        canvasCtx.fillStyle = '#181818';
        canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

        const barWidth = (WIDTH / bufferLength) * 1.5;
        let x = 0;
        for(let i = 0; i < bufferLength; i++) {
          const barHeight = dataArray[i] / 2;
          const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
          canvasCtx.fillStyle = primaryColor;
          canvasCtx.fillRect(x, HEIGHT - barHeight, barWidth, barHeight);
          x += barWidth + 1;
        }
      }

      draw();
    } catch(e) {
      console.warn("Visualizer not supported or audio context could not be started.", e);
    }
  }

  // Resize visualizer canvas on window resize
  window.addEventListener('resize', () => {
    if(visualizerCanvas) {
      visualizerCanvas.width = visualizerCanvas.clientWidth;
      visualizerCanvas.height = visualizerCanvas.clientHeight;
    }
  });

  // Playlist editing functions
  function moveTrackInPlaylist(oldIndex, newIndex) {
      if (newIndex < 0 || newIndex >= playlist.length || oldIndex === newIndex) {
          return; // Invalid move
      }

      const [movedTrack] = playlist.splice(oldIndex, 1);
      playlist.splice(newIndex, 0, movedTrack);

      // If the currently playing track was moved, update its index
      if (currentIndex === oldIndex) {
          currentIndex = newIndex;
      } else if (currentIndex > oldIndex && currentIndex <= newIndex) {
          currentIndex--; // Adjust index if track moved past current
      } else if (currentIndex < oldIndex && currentIndex >= newIndex) {
          currentIndex++; // Adjust index if track moved into current's original spot
      }

      savePlaylist();
      renderPlaylist(); // Re-render to reflect new order
      updatePlaylistActive(); // Ensure active class is correct after re-render
  }

  function removeTrackFromPlaylist(indexToRemove) {
      if (indexToRemove < 0 || indexToRemove >= playlist.length) {
          return; // Invalid index
      }

      const removedTrack = playlist.splice(indexToRemove, 1)[0];

      // If the removed track was the currently playing one
      if (currentIndex === indexToRemove) {
          pauseAudio(); // Pause playback
          currentIndex = -1; // No track selected
          updateCoverArt(defaultCoverArt);
          currentSongTitleEl.textContent = locale.noTrack; // Reset current song info
          currentSongArtistEl.textContent = '';
          progressBar.style.width = '0%'; // Reset progress bar
          updatePlayPauseButton();
      } else if (currentIndex > indexToRemove) {
          currentIndex--; // Adjust current index if a track before it was removed
      }

      savePlaylist();
      renderPlaylist(); // Re-render to reflect removal
      renderLibraryList(currentFilter.type); // Update library list
      updatePlaylistActive(); // Update active class (might be none)
      console.log(`Track "${removedTrack.title}" removed from playlist.`);
  }

  // NEW: Edit Track Info
  function editTrackInfo(trackId) {
    const trackIndex = playlist.findIndex(t => t.id === trackId);
    if (trackIndex === -1) return;

    const track = playlist[trackIndex];

    const newTitle = prompt(locale.promptTitle, track.title);
    if (newTitle === null) return; // User cancelled

    const newArtist = prompt(locale.promptArtist, track.artist);
    if (newArtist === null) return;

    const newAlbum = prompt(locale.promptAlbum, track.album);
    if (newAlbum === null) return;

    const newGenre = prompt(locale.promptGenre, track.genre);
    if (newGenre === null) return;

    playlist[trackIndex].title = newTitle.trim() || 'Unknown Title';
    playlist[trackIndex].artist = newArtist.trim() || 'Unknown Artist';
    playlist[trackIndex].album = newAlbum.trim() || locale.unknownAlbum;
    playlist[trackIndex].genre = newGenre.trim() || locale.unknownGenre;

    savePlaylist();
    renderPlaylist(); // Update playlist display
    renderLibraryList(currentFilter.type); // Update library display
    alert(locale.confirmEdit);
    // If currently playing, update display immediately
    if (currentIndex === trackIndex) {
      currentSongTitleEl.textContent = playlist[currentIndex].title;
      currentSongArtistEl.textContent = playlist[currentIndex].artist;
    }
  }


  // Progress Bar Logic
  function updateProgressBar() {
    const progress = (audio.currentTime / audio.duration) * 100;
    progressBar.style.width = `${progress || 0}%`;
  }

  function seekAudio(e) {
    const rect = progressBarContainer.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const width = rect.width;
    const seekTime = (clickX / width) * audio.duration;
    audio.currentTime = seekTime;
  }

  // Helper to convert hex to RGB for dynamic RGBA colors
  function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `${r}, ${g}, ${b}`;
  }

  // NEW: Tab Switching Logic
  function showTab(tabId) {
    // Deactivate all tabs and content
    document.querySelectorAll('#tab-navigation button').forEach(btn => {
      btn.classList.remove('active');
      btn.setAttribute('aria-selected', 'false');
      btn.setAttribute('tabindex', '-1');
    });
    document.querySelectorAll('.tab-content').forEach(content => {
      content.classList.remove('active');
      content.style.display = 'none';
    });

    // Activate the selected tab and content
    const selectedTabBtn = document.getElementById(tabId + '-btn');
    const selectedTabContent = document.getElementById(tabId + '-content');

    if (selectedTabBtn && selectedTabContent) {
      selectedTabBtn.classList.add('active');
      selectedTabBtn.setAttribute('aria-selected', 'true');
      selectedTabBtn.setAttribute('tabindex', '0');
      selectedTabContent.classList.add('active');
      selectedTabContent.style.display = 'flex'; // Use flex for column layout
    }
    // Render the library list whenever the library tab is shown or the filter changes
    if (tabId === 'library-tab') {
      renderLibraryList(currentFilter.type);
    }
  }

  // NEW: Library Browse Functions
  function renderLibraryList(viewType) {
    libraryListEl.innerHTML = '';
    let itemsToDisplay = [];
    let titleProperty = '';

    // Deactivate all filter buttons
    document.querySelectorAll('#library-filter-nav button').forEach(btn => btn.classList.remove('active'));

    // Set active class for current view button
    if (viewType === 'all') {
      viewAllSongsBtn.classList.add('active');
      itemsToDisplay = [...playlist].sort((a, b) => a.title.localeCompare(b.title));
      titleProperty = 'title';
      // If we're showing all songs in the library tab, we should also clear any filter in the playlist tab
      clearFilter(); // Immediately clear the filter
    } else if (viewType === 'albums') {
      viewAlbumsBtn.classList.add('active');
      itemsToDisplay = getUniqueAlbums().sort((a, b) => a.name.localeCompare(b.name));
      titleProperty = 'name';
    } else if (viewType === 'artists') {
      viewArtistsBtn.classList.add('active');
      itemsToDisplay = getUniqueArtists().sort((a, b) => a.name.localeCompare(b.name));
      titleProperty = 'name';
    } else if (viewType === 'genres') {
      viewGenresBtn.classList.add('active');
      itemsToDisplay = getUniqueGenres().sort((a, b) => a.name.localeCompare(b.name));
      titleProperty = 'name';
    } else {
        // Fallback or specific filtered view - render all songs in playlist directly.
        // This case is for when you click on a specific album/artist/genre.
        // The library list should then show the *songs* of that filtered group.
        // For simplicity here, we'll just switch to playlist tab with filter.
        return;
    }

    if(itemsToDisplay.length === 0) {
      const emptyMsg = document.createElement('li');
      emptyMsg.textContent = `No ${viewType} found.`; // Generic message
      emptyMsg.style.padding = '10px 20px';
      emptyMsg.style.color = '#777';
      emptyMsg.style.textAlign = 'center';
      libraryListEl.appendChild(emptyMsg);
      return;
    }

    itemsToDisplay.forEach(itemData => {
      const itemEl = document.createElement('li');
      itemEl.className = 'library-list-item';
      itemEl.tabIndex = 0;

      const nameSpan = document.createElement('span');
      nameSpan.textContent = itemData[titleProperty];
      itemEl.appendChild(nameSpan);

      if (itemData.count !== undefined) { // For albums, artists, genres
        const countSpan = document.createElement('span');
        countSpan.className = 'count';
        countSpan.textContent = `(${itemData.count})`;
        itemEl.appendChild(countSpan);
      }

      itemEl.addEventListener('click', () => {
        if (viewType === 'all') {
            // If already showing all songs, clicking a song should play it
            const originalIndex = playlist.indexOf(itemData);
            if (originalIndex !== -1) {
                const track = playlist[originalIndex];
                playTrack(originalIndex, track.isDownloaded ? track.offlineUrl : track.url);
                showTab('playlist-tab'); // Switch to playlist tab
            }
        } else {
            // Apply filter and switch to playlist tab
            currentFilter.type = viewType.slice(0, -1); // e.g., 'albums' -> 'album'
            currentFilter.value = itemData.name;
            renderPlaylist(); // Re-render playlist with filter
            showTab('playlist-tab'); // Switch to playlist tab
        }
      });
      libraryListEl.appendChild(itemEl);
    });
  }

  function getUniqueAlbums() {
    const albums = {};
    playlist.forEach(track => {
      const albumName = track.album || locale.unknownAlbum;
      if (!albums[albumName]) {
        albums[albumName] = { name: albumName, count: 0 };
      }
      albums[albumName].count++;
    });
    return Object.values(albums);
  }

  function getUniqueArtists() {
    const artists = {};
    playlist.forEach(track => {
      const artistName = track.artist || locale.unknownArtist;
      if (!artists[artistName]) {
        artists[artistName] = { name: artistName, count: 0 };
      }
      artists[artistName].count++;
    });
    return Object.values(artists);
  }

  function getUniqueGenres() {
    const genres = {};
    playlist.forEach(track => {
      const genreName = track.genre || locale.unknownGenre;
      if (!genres[genreName]) {
        genres[genreName] = { name: genreName, count: 0 };
      }
      genres[genreName].count++;
    });
    return Object.values(genres);
  }

  function clearFilter() {
    currentFilter = { type: 'all', value: null };
    renderPlaylist(); // Re-render playlist to clear filter
    // Also re-render library list to reset active button if needed
    renderLibraryList('all');
  }


  // Initialize
  function init() {
    // 1. Load playlist from LocalStorage
    loadPlaylist();

    // Event listeners
    playPauseBtn.addEventListener('click', togglePlayPause);
    prevBtn.addEventListener('click', playPrev);
    nextBtn.addEventListener('click', playNext);
    shuffleBtn.addEventListener('click', toggleShuffle);
    repeatBtn.addEventListener('click', toggleRepeat);
    searchInput.addEventListener('input', renderPlaylist); // Still needed for playlist tab
    playStreamBtn.addEventListener('click', playStream);

    addMusicBtn.addEventListener('click', () => addMusicFileInput.click());
    addMusicFileInput.addEventListener('change', (e) => {
      handleFilesFromInput(e.target.files);
      addMusicFileInput.value = ''; // Clear input to allow adding same file again
    });

    exportPlaylistBtn.addEventListener('click', exportPlaylist);
    importPlaylistBtn.addEventListener('click', () => importFileInput.click());
    importFileInput.addEventListener('change', e => {
      importPlaylistFromFile(e.target.files[0]);
      importFileInput.value = ''; // Clear input
    });
    mp3ConverterBtn.addEventListener('click', () => {
        window.open('https://www.freeconvert.com/mp3-converter', '_blank');
    });
    preloadAllBtn.addEventListener('click', preloadAllMusic);

    container.addEventListener('dragover', onDragOver);
    container.addEventListener('dragleave', onDragLeave);
    container.addEventListener('drop', onDrop);

    window.addEventListener('keydown', onKeyDown);

    audio.addEventListener('ended', playNext);
    audio.addEventListener('timeupdate', updateProgressBar); // Update progress bar
    progressBarContainer.addEventListener('click', seekAudio); // Seek functionality

    audio.addEventListener('play', () => {
      isPlaying = true;
      updatePlayPauseButton();
      if(audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume().catch(e => console.error("Failed to resume AudioContext:", e));
      }
    });
    audio.addEventListener('pause', () => {
      isPlaying = false;
      updatePlayPauseButton();
    });

    langSelect.addEventListener('change', () => {
      const val = langSelect.value;
      locale = locales[val] || locales.en;
      updateLocaleTexts();
      renderPlaylist(); // Rerender playlist as text might change
      renderLibraryList(currentFilter.type); // Re-render library list
    });

    themeColorPicker.addEventListener('input', (e) => {
      const newColor = e.target.value;
      document.documentElement.style.setProperty('--primary-color', newColor);
      // Set RGB variable for dynamic RGBA in CSS
      document.documentElement.style.setProperty('--primary-color-rgb', hexToRgb(newColor));
      updatePlaylistActive(); // Reapply active style with new color
      // Also update scrollbar color if it uses primary-color directly
      document.documentElement.style.setProperty('scrollbar-color', `var(--primary-color) #2a2a2a`);
    });
    // Set initial RGB variable and scrollbar color
    document.documentElement.style.setProperty('--primary-color-rgb', hexToRgb(themeColorPicker.value));
    document.documentElement.style.setProperty('scrollbar-color', `var(--primary-color) #2a2a2a`);


    updateCoverArt(defaultCoverArt);
    // Ensure playlist is rendered and download status checked before attempting autoplay
    checkAllTracksDownloadStatus().then(() => {
      if (playlist.length > 0) {
        // Just show the info for the first song without auto-playing if not already playing
        const firstTrack = playlist[0];
        currentSongTitleEl.textContent = firstTrack.title;
        currentSongArtistEl.textContent = firstTrack.artist;
        updateCoverArt(firstTrack.cover);
      } else {
        updateLocaleTexts(); // Set "No track playing" if playlist is empty
      }
      renderPlaylist(); // Ensure playlist is rendered initially
      renderLibraryList('all'); // Render library list with 'all' songs view initially
    });

    setupVisualizer();

    // Tab button event listeners
    libraryTabBtn.addEventListener('click', () => showTab('library-tab')); // Renamed
    playlistTabBtn.addEventListener('click', () => showTab('playlist-tab'));

    // Library Filter Nav buttons
    viewAllSongsBtn.addEventListener('click', () => renderLibraryList('all'));
    viewAlbumsBtn.addEventListener('click', () => renderLibraryList('albums'));
    viewArtistsBtn.addEventListener('click', () => renderLibraryList('artists'));
    viewGenresBtn.addEventListener('click', () => renderLibraryList('genres'));
    clearFilterBtn.addEventListener('click', clearFilter);


    // Set initial active tab
    showTab('playlist-tab'); // Default to showing the playlist tab

    // Service Worker Registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered with scope:', registration.scope);
          })
          .catch((error) => {
            console.error('Service Worker registration failed:', error);
          });
      });
    }
  }

  init();

})();
</script>
</body>
</html>