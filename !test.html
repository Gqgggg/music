<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Music Player</title>

<link rel="manifest" href="/manifest.json">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Music Player">
<link rel="apple-touch-icon" href="/icons/icon-192x192.png">

<style>
  /* Reset */
  * {
    box-sizing: border-box;
  }

  :root {
    --primary-color: #ff6f61; /* Define a CSS variable for the primary color */
    --background-dark: #121212;
    --background-medium: #1e1e1e;
    --background-light: #272727;
    --text-color: #eee;
    --text-muted: #aaa;
    --border-color: #2a2a2a;
    --shadow-color: rgba(0, 0, 0, 0.6);
    --primary-color-rgb: 255, 111, 97; /* Default RGB for primary color */
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: var(--background-dark);
    color: var(--text-color);
    margin: 0;
    padding: 20px;
    display: flex;
    justify-content: center;
    align-items: flex-start; /* Align to top to allow more space for content */
    min-height: 100vh;
  }

  .container {
    background-color: var(--background-medium);
    border-radius: 12px;
    box-shadow: 0 8px 30px var(--shadow-color);
    width: 100%;
    max-width: 900px;
    display: flex;
    flex-direction: column;
    overflow: hidden; /* For rounded corners */
  }

  header {
    background-color: var(--background-light);
    padding: 15px 20px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  header h1 {
    margin: 0;
    font-size: 1.5em;
    color: var(--primary-color);
  }

  nav.tabs {
    display: flex;
    justify-content: space-around;
    background-color: var(--background-dark);
    border-bottom: 1px solid var(--border-color);
  }

  .tab-button {
    flex-grow: 1;
    padding: 15px 0;
    text-align: center;
    color: var(--text-muted);
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.2s, color 0.2s;
  }

  .tab-button:hover:not(.active) {
    background-color: var(--background-light);
  }

  .tab-button.active {
    color: var(--text-color);
    background-color: var(--background-medium);
    border-bottom: 3px solid var(--primary-color);
  }

  main {
    flex-grow: 1;
    padding: 20px;
  }

  .tab-content {
    display: none;
  }

  .tab-content.active {
    display: block;
  }

  /* Library Tab Specifics */
  .library-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    gap: 10px;
    flex-wrap: wrap; /* Allow wrapping on smaller screens */
  }

  .library-controls button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.9em;
    transition: background-color 0.2s;
  }

  .library-controls button:hover {
    background-color: #e65c50;
  }

  .library-controls .file-input-wrapper {
    position: relative;
    overflow: hidden;
    display: inline-block;
    background-color: var(--background-light); /* Match background for a cohesive look */
    color: var(--text-color);
    border: 1px solid var(--border-color);
    padding: 10px 15px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.9em;
  }

  .library-controls .file-input-wrapper input[type="file"] {
    position: absolute;
    left: 0;
    top: 0;
    opacity: 0;
    cursor: pointer;
    width: 100%;
    height: 100%;
  }

  .library-filter-nav {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-bottom: 20px;
  }

  .library-filter-nav button {
    background-color: var(--background-light);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.85em;
    transition: background-color 0.2s, border-color 0.2s;
  }

  .library-filter-nav button:hover {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
  }

  .library-list, .playlist-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 400px; /* Example max height for scroll */
    overflow-y: auto;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--background-dark);
  }

  .library-list li, .playlist-list li {
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.2s;
  }

  .library-list li:last-child, .playlist-list li:last-child {
    border-bottom: none;
  }

  .library-list li:hover, .playlist-list li:hover {
    background-color: var(--background-light);
  }

  .library-list li.playing {
    background-color: rgba(var(--primary-color-rgb), 0.2); /* Highlight playing track */
    border-left: 3px solid var(--primary-color);
  }

  .track-info {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
  }

  .track-info span {
    font-size: 0.9em;
    color: var(--text-muted);
  }

  .playlist-actions button {
    background: none;
    border: none;
    color: var(--primary-color);
    font-size: 1.2em;
    cursor: pointer;
    margin-left: 10px;
    transition: color 0.2s;
  }

  .playlist-actions button:hover {
    color: #e65c50;
  }

  .no-songs-message {
    text-align: center;
    padding: 20px;
    color: var(--text-muted);
  }

  /* Player Controls */
  .player-controls-container {
    background-color: var(--background-light);
    padding: 20px;
    border-top: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  .current-track-info {
    text-align: center;
  }

  .current-track-info h3 {
    margin: 0 0 5px 0;
    color: var(--text-color);
    font-size: 1.2em;
  }

  .current-track-info p {
    margin: 0;
    color: var(--text-muted);
    font-size: 0.9em;
  }

  .progress-bar-container {
    width: 100%;
    height: 6px;
    background-color: var(--background-dark);
    border-radius: 3px;
    cursor: pointer;
    position: relative;
    margin-bottom: 10px;
  }

  .progress-bar {
    height: 100%;
    width: 0%;
    background-color: var(--primary-color);
    border-radius: 3px;
    transition: width 0.1s linear; /* Smooth progress update */
  }

  .time-info {
    display: flex;
    justify-content: space-between;
    font-size: 0.85em;
    color: var(--text-muted);
    margin-top: -5px;
    margin-bottom: 10px;
  }

  .player-buttons {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-bottom: 15px;
  }

  .player-buttons button {
    background: none;
    border: none;
    color: var(--text-color);
    font-size: 2em;
    cursor: pointer;
    transition: color 0.2s;
  }

  .player-buttons button:hover {
    color: var(--primary-color);
  }

  .volume-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    justify-content: center;
  }

  .volume-controls input[type="range"] {
    flex-grow: 1;
    max-width: 200px;
    -webkit-appearance: none;
    background: var(--background-dark);
    border-radius: 5px;
    height: 8px;
    outline: none;
  }

  .volume-controls input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: var(--primary-color);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
  }

  .volume-controls input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    background: var(--primary-color);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
  }

  /* Stream URL input */
  .stream-input-group {
    display: flex;
    gap: 10px;
    margin-top: 15px;
    flex-wrap: wrap; /* Allow wrapping on smaller screens */
  }

  .stream-input-group input[type="text"] {
    flex-grow: 1;
    padding: 10px 15px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--background-dark);
    color: var(--text-color);
    font-size: 0.9em;
  }

  .stream-input-group button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.9em;
    transition: background-color 0.2s;
    white-space: nowrap; /* Prevent button text from wrapping */
  }

  .stream-input-group button:hover {
    background-color: #e65c50;
  }

  /* Visualizer */
  #visualizer {
    background-color: var(--background-dark);
    border-radius: 8px;
    margin-bottom: 20px;
    width: 100%; /* Take full width */
    height: 120px; /* Fixed height for visualizer */
    border: 1px solid var(--border-color);
  }

  @media (max-width: 600px) {
    body {
      padding: 10px;
    }

    .container {
      max-width: 100%;
      border-radius: 0;
    }

    header {
      flex-direction: column;
      text-align: center;
    }

    .library-controls, .stream-input-group {
      flex-direction: column;
      gap: 10px;
    }

    .library-controls .file-input-wrapper,
    .stream-input-group input[type="text"],
    .stream-input-group button {
      width: 100%;
    }

    .library-filter-nav {
      justify-content: center;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Advanced Music Player</h1>
      <div class="settings">
        </div>
    </header>

    <nav class="tabs">
      <div class="tab-button active" id="playlist-tab-btn">Playlist</div>
      <div class="tab-button" id="library-tab-btn">Library</div>
    </nav>

    <main>
      <div class="tab-content active" id="playlist-tab">
        <ul class="playlist-list" id="playlist-list">
          </ul>
        <p id="no-playlist-message" class="no-songs-message" style="display: none;">Your playlist is empty. Add some music from the Library or by streaming!</p>
      </div>

      <div class="tab-content" id="library-tab">
        <div class="library-controls">
          <div class="file-input-wrapper">
            <input type="file" id="add-music-file-input" accept="audio/*" multiple />
            <span>Add Local Music</span>
          </div>
          <input type="text" id="youtube-url-input" placeholder="Paste YouTube Video URL" />
          <button id="play-youtube-btn">Play YouTube Audio</button>
        </div>

        <div class="stream-input-group">
            <input type="text" id="stream-url-input" placeholder="Enter MP3/AAC stream URL" />
            <button id="play-stream-btn">Play Stream</button>
        </div>

        <nav class="library-filter-nav">
          <button id="view-all-songs-btn">All Songs</button>
          <button id="view-albums-btn">Albums</button>
          <button id="view-artists-btn">Artists</button>
          <button id="view-genres-btn">Genres</button>
          <button id="clear-filter-btn">Clear Filter</button>
        </nav>
        <ul class="library-list" id="library-list">
          </ul>
        <p id="no-library-message" class="no-songs-message" style="display: none;">Your music library is empty. Add some local files!</p>
      </div>
    </main>

    <div class="player-controls-container">
      <canvas id="visualizer"></canvas>

      <div class="current-track-info">
        <h3 id="current-track-title">No track playing</h3>
        <p id="current-track-artist">Artist - Album</p>
      </div>

      <div class="progress-bar-container" id="progress-bar-container">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
      <div class="time-info">
        <span id="current-time">0:00</span>
        <span id="duration">0:00</span>
      </div>

      <div class="player-buttons">
        <button id="prev-btn">⏮️</button>
        <button id="play-pause-btn">▶️</button>
        <button id="next-btn">⏭️</button>
      </div>

      <div class="volume-controls">
        <span>🔇</span>
        <input type="range" id="volume-slider" min="0" max="100" value="75" />
        <span>🔊</span>
      </div>
    </div>
  </div>

  <div id="youtube-player" style="display: none;"></div>

  <script src="https://www.youtube.com/iframe_api" async></script>

  <script>
    // Your existing JavaScript code will go here.
    // I'll provide the YouTube integration part below.
    // ... (Your existing JavaScript init() function and other code) ...

    (function() {
      // --- IndexedDB Setup ---
      const IDB_DATABASE_NAME = 'music-db';
      const IDB_STORE_NAME = 'tracks';
      let db; // Global IndexedDB database instance

      function openIndexedDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(IDB_DATABASE_NAME, 1);

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(IDB_STORE_NAME)) {
              db.createObjectStore(IDB_STORE_NAME, { keyPath: 'id', autoIncrement: true });
            }
          };

          request.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
          };

          request.onerror = (event) => {
            console.error('IndexedDB error:', event.target.error);
            reject(event.target.error);
          };
        });
      }

      // --- Audio Context and Visualizer ---
      let audioContext;
      let analyser;
      let sourceNode;
      let visualizerCanvas;
      let visualizerCtx;
      let bufferLength;
      let dataArray;

      function setupVisualizer() {
        visualizerCanvas = document.getElementById('visualizer');
        visualizerCtx = visualizerCanvas.getContext('2d');
        visualizerCanvas.width = visualizerCanvas.offsetWidth; // Set canvas resolution
        visualizerCanvas.height = visualizerCanvas.offsetHeight;

        // Create AudioContext only on user gesture
        document.addEventListener('click', initAudioContext, { once: true });
        document.addEventListener('keydown', initAudioContext, { once: true });
      }

      function initAudioContext() {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256; // Fast Fourier Transform size (number of samples in frequency data)
          bufferLength = analyser.frequencyBinCount; // Number of data points (half of fftSize)
          dataArray = new Uint8Array(bufferLength); // Array to hold frequency data

          // Connect analyser to output
          analyser.connect(audioContext.destination);
          drawVisualizer(); // Start drawing once context is ready
        }
      }

      function connectSourceToVisualizer(audioNode) {
        // Disconnect old source if it exists
        if (sourceNode) {
          sourceNode.disconnect(analyser);
        }
        sourceNode = audioNode;
        sourceNode.connect(analyser);
      }

      function drawVisualizer() {
        requestAnimationFrame(drawVisualizer); // Loop this function

        analyser.getByteFrequencyData(dataArray); // Get frequency data

        visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height); // Clear canvas

        const barWidth = (visualizerCanvas.width / bufferLength) * 2.5; // Calculate bar width
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
          const barHeight = dataArray[i]; // Get bar height from frequency data

          // Draw a rectangle for each bar
          visualizerCtx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`; // Color based on height
          visualizerCtx.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight);

          x += barWidth + 1; // Move to the right for the next bar
        }
      }

      // --- Track Management (Local Files and Streams) ---
      let library = []; // Stores all tracks added by the user
      let playlist = []; // The currently active playlist
      let currentTrackIndex = -1;
      let audio = new Audio(); // HTML5 Audio element for local files and direct streams
      let isPlaying = false;
      let currentTrackType = 'local'; // 'local', 'stream', or 'youtube'

      // DOM Elements
      const addMusicFileInput = document.getElementById('add-music-file-input');
      const streamUrlInput = document.getElementById('stream-url-input');
      const playStreamBtn = document.getElementById('play-stream-btn');
      const playlistList = document.getElementById('playlist-list');
      const libraryList = document.getElementById('library-list');
      const noPlaylistMessage = document.getElementById('no-playlist-message');
      const noLibraryMessage = document.getElementById('no-library-message');

      const playPauseBtn = document.getElementById('play-pause-btn');
      const prevBtn = document.getElementById('prev-btn');
      const nextBtn = document.getElementById('next-btn');
      const volumeSlider = document.getElementById('volume-slider');
      const progressBar = document.getElementById('progress-bar');
      const progressBarContainer = document.getElementById('progress-bar-container');
      const currentTimeSpan = document.getElementById('current-time');
      const durationSpan = document.getElementById('duration');
      const currentTrackTitle = document.getElementById('current-track-title');
      const currentTrackArtist = document.getElementById('current-track-artist');

      // Tab Buttons
      const playlistTabBtn = document.getElementById('playlist-tab-btn');
      const libraryTabBtn = document.getElementById('library-tab-btn');
      const playlistTab = document.getElementById('playlist-tab');
      const libraryTab = document.getElementById('library-tab');

      // Library Filter Buttons
      const viewAllSongsBtn = document.getElementById('view-all-songs-btn');
      const viewAlbumsBtn = document.getElementById('view-albums-btn');
      const viewArtistsBtn = document.getElementById('view-artists-btn');
      const viewGenresBtn = document.getElementById('view-genres-btn');
      const clearFilterBtn = document.getElementById('clear-filter-btn');

      // --- YouTube Integration Elements ---
      const youtubeUrlInput = document.getElementById('youtube-url-input');
      const playYoutubeBtn = document.getElementById('play-youtube-btn');
      let youtubePlayer; // Variable to hold the YouTube player instance

      // --- YouTube IFrame Player API Functions ---
      // This function is called by the YouTube API when it's fully loaded.
      window.onYouTubeIframeAPIReady = function() {
          console.log("YouTube IFrame API is Ready.");
          youtubePlayer = new YT.Player('youtube-player', {
              height: '0', // Make the player invisible
              width: '0',  // Make the player invisible
              videoId: '', // No video ID initially
              playerVars: {
                  'autoplay': 1,
                  'controls': 0,
                  'disablekb': 1,
                  'modestbranding': 1,
                  'rel': 0,
                  'enablejsapi': 1,
                  'html5': 1 // Prefer HTML5 player over Flash
              },
              events: {
                  'onReady': onPlayerReady,
                  'onStateChange': onPlayerStateChange
              }
          });
      };

      function onPlayerReady(event) {
          console.log('YouTube player ready. Event:', event);
          // Set initial volume for YouTube player
          if (youtubePlayer) {
              youtubePlayer.setVolume(volumeSlider.value);
          }
          // Optionally, you can immediately play a video if you have a default
          // event.target.playVideo();
      }

      function onPlayerStateChange(event) {
          console.log('YouTube player state changed:', event.data);
          const state = event.data;
          switch (state) {
              case YT.PlayerState.PLAYING:
                  isPlaying = true;
                  updatePlayPauseButton();
                  // If switching from local/stream to YouTube, ensure visualizer connects
                  if (currentTrackType === 'youtube' && !sourceNode) {
                      // Get the AudioContext from the YouTube player's iframe if possible,
                      // or connect a new source node. This is a bit advanced,
                      // for simplicity, we'll assume the visualizer works with
                      // the primary audio context, which might not directly receive YouTube audio.
                      // More complex setup needed to route YouTube audio through your AudioContext.
                      // For now, visualizer might not show for YouTube.
                      // You'd need to create an Audio object for the youtube stream, or use a library that bridges.
                  }
                  break;
              case YT.PlayerState.PAUSED:
                  isPlaying = false;
                  updatePlayPauseButton();
                  break;
              case YT.PlayerState.ENDED:
                  playNextTrack(); // Auto-play next if YouTube track ends
                  break;
              case YT.PlayerState.BUFFERING:
                  // Show buffering indicator if you have one
                  break;
              case YT.PlayerState.CUED:
                  // Video is cued but not playing
                  break;
              default:
                  // Other states like unstarted
                  break;
          }
          updateProgressBarAndTimer(); // Update UI for YouTube playback
      }

      function playYouTubeAudio(videoId) {
          if (!youtubePlayer) {
              console.error("YouTube player not initialized.");
              // Fallback or error message to user
              return;
          }
          // Pause current local/stream playback if any
          if (!audio.paused) {
              audio.pause();
          }
          currentTrackType = 'youtube';
          currentTrackIndex = -1; // No specific index in playlist for YouTube stream

          youtubePlayer.loadVideoById(videoId);
          isPlaying = true;
          updatePlayPauseButton();

          currentTrackTitle.textContent = "YouTube Video"; // You could fetch title via API
          currentTrackArtist.textContent = `Playing from YouTube: ${videoId}`;
          // Duration for YouTube is harder to get instantly without event listeners
          durationSpan.textContent = '0:00'; // Will update as video plays
      }

      function extractYouTubeVideoId(url) {
          const regExp = /(?:youtube\.com\/(?:[^\/]+\/.+\/|\/(?:v|e(?:mbed)?)\/|watch\?v=)|youtu\.be\/)([^&?#]{11})/;
          const match = url.match(regExp);
          return (match && match[1]) ? match[1] : null;
      }

      // --- General Player Control Functions (adapted for YouTube) ---
      function playCurrentTrack() {
        if (currentTrackType === 'youtube' && youtubePlayer) {
            youtubePlayer.playVideo();
        } else if (playlist[currentTrackIndex]) {
            const track = playlist[currentTrackIndex];
            if (track.type === 'local') {
                audio.src = URL.createObjectURL(track.file);
            } else if (track.type === 'stream') {
                audio.src = track.url;
            }
            audio.play().catch(e => console.error("Error playing audio:", e));
            connectSourceToVisualizer(audioContext.createMediaElementSource(audio));
            currentTrackType = track.type;
        }
        isPlaying = true;
        updatePlayPauseButton();
        updateCurrentTrackInfo();
      }

      function pauseCurrentTrack() {
        if (currentTrackType === 'youtube' && youtubePlayer) {
            youtubePlayer.pauseVideo();
        } else {
            audio.pause();
        }
        isPlaying = false;
        updatePlayPauseButton();
      }

      function togglePlayPause() {
        if (isPlaying) {
          pauseCurrentTrack();
        } else {
          // If no track is playing and playlist is not empty, start from beginning
          if (currentTrackIndex === -1 && playlist.length > 0) {
            currentTrackIndex = 0;
          }
          playCurrentTrack();
        }
      }

      function playNextTrack() {
        if (currentTrackType === 'youtube') {
            // For YouTube, if a specific playlist is not managed within the app,
            // 'next' might not make sense or could go to the next cued YouTube video.
            // For now, if a YouTube track ends, we can simply stop or clear the player.
            // Or, if you want to integrate YouTube videos into your playlist,
            // you'd add them as 'youtube' type tracks in your `playlist` array.
            if (playlist.length > 0 && currentTrackIndex >= 0 && currentTrackIndex < playlist.length -1) {
                currentTrackIndex++;
                playCurrentTrack(); // Play next local/stream track
            } else {
                // If it was the last YouTube track or playlist is empty, stop
                pauseCurrentTrack();
                currentTrackTitle.textContent = "No track playing";
                currentTrackArtist.textContent = "";
                durationSpan.textContent = "0:00";
                currentTimeSpan.textContent = "0:00";
                progressBar.style.width = '0%';
                if (youtubePlayer) youtubePlayer.stopVideo();
            }
            return;
        }


        if (playlist.length === 0) return;
        currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
        playCurrentTrack();
      }

      function playPrevTrack() {
        if (currentTrackType === 'youtube') {
            // Similar logic to playNextTrack for YouTube
            if (playlist.length > 0 && currentTrackIndex > 0) {
                currentTrackIndex--;
                playCurrentTrack(); // Play previous local/stream track
            } else {
                // If it was the first YouTube track or playlist is empty, stop
                pauseCurrentTrack();
                currentTrackTitle.textContent = "No track playing";
                currentTrackArtist.textContent = "";
                durationSpan.textContent = "0:00";
                currentTimeSpan.textContent = "0:00";
                progressBar.style.width = '0%';
                if (youtubePlayer) youtubePlayer.stopVideo();
            }
            return;
        }

        if (playlist.length === 0) return;
        currentTrackIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
        playCurrentTrack();
      }

      function updatePlayPauseButton() {
        playPauseBtn.textContent = isPlaying ? '⏸️' : '▶️';
      }

      function updateCurrentTrackInfo() {
        if (currentTrackType === 'youtube') {
            // Info is set in playYouTubeAudio
            return;
        }
        if (playlist[currentTrackIndex]) {
          const track = playlist[currentTrackIndex];
          currentTrackTitle.textContent = track.title || track.name || 'Unknown Title';
          currentTrackArtist.textContent = track.artist ? `${track.artist} - ${track.album || 'Unknown Album'}` : 'Unknown Artist - Unknown Album';
        } else {
          currentTrackTitle.textContent = 'No track playing';
          currentTrackArtist.textContent = '';
        }
      }

      function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
      }

      function updateProgressBarAndTimer() {
        let current = 0;
        let total = 0;

        if (currentTrackType === 'youtube' && youtubePlayer && youtubePlayer.getPlayerState() === YT.PlayerState.PLAYING) {
            current = youtubePlayer.getCurrentTime();
            total = youtubePlayer.getDuration();
        } else if (audio && !isNaN(audio.duration)) {
            current = audio.currentTime;
            total = audio.duration;
        }

        currentTimeSpan.textContent = formatTime(current);
        durationSpan.textContent = formatTime(total);

        if (total > 0) {
          const progress = (current / total) * 100;
          progressBar.style.width = `${progress}%`;
        } else {
          progressBar.style.width = '0%';
        }
      }

      // --- Track Adding and Rendering ---
      async function addLocalFiles(files) {
        for (const file of files) {
          if (file.type.startsWith('audio/')) {
            const track = {
              id: Date.now() + Math.random(), // Simple unique ID
              name: file.name,
              file: file,
              type: 'local',
              title: file.name.replace(/\.[^/.]+$/, ""), // Remove extension for title
              artist: 'Unknown Artist', // Can be parsed from metadata later
              album: 'Unknown Album',
              genre: 'Unknown Genre'
            };
            await saveTrackToIndexedDB(track);
          }
        }
        await loadTracksFromIndexedDB(); // Reload library from DB
        renderLibraryList('all'); // Re-render library list after adding files
      }

      async function saveTrackToIndexedDB(track) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(IDB_STORE_NAME, 'readwrite');
          const store = transaction.objectStore(IDB_STORE_NAME);
          const request = store.add(track);

          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function loadTracksFromIndexedDB() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(IDB_STORE_NAME, 'readonly');
          const store = transaction.objectStore(IDB_STORE_NAME);
          const request = store.getAll();

          request.onsuccess = (event) => {
            library = event.target.result;
            // Filter out non-local tracks if necessary when loading library from DB
            library = library.filter(t => t.type === 'local');
            resolve();
          };

          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function deleteTrackFromIndexedDB(id) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(IDB_STORE_NAME, 'readwrite');
          const store = transaction.objectStore(IDB_STORE_NAME);
          const request = store.delete(id);

          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        });
      }


      function renderLibraryList(filterType = 'all', filterValue = '') {
        libraryList.innerHTML = ''; // Clear previous list
        let filteredLibrary = [];

        if (filterType === 'all') {
          filteredLibrary = library;
        } else if (filterType === 'albums') {
          const albums = [...new Set(library.map(t => t.album || 'Unknown Album'))];
          if (!filterValue) { // Show album titles for selection
              albums.forEach(album => {
                  const li = document.createElement('li');
                  li.textContent = `Album: ${album}`;
                  li.classList.add('album-filter-item');
                  li.dataset.filterValue = album;
                  li.addEventListener('click', () => renderLibraryList('albums', album));
                  libraryList.appendChild(li);
              });
              noLibraryMessage.style.display = albums.length === 0 ? 'block' : 'none';
              return; // Exit as we're showing album choices, not tracks
          } else { // Show tracks for selected album
              filteredLibrary = library.filter(track => (track.album || 'Unknown Album') === filterValue);
          }
        }
        // ... (Similar logic for artists, genres)

        if (filteredLibrary.length === 0) {
          noLibraryMessage.style.display = 'block';
          return;
        }
        noLibraryMessage.style.display = 'none';

        filteredLibrary.forEach((track, index) => {
          const li = document.createElement('li');
          li.dataset.index = index; // Use index in filtered list for display
          li.dataset.trackId = track.id; // Store actual track ID for playing/deletion

          li.innerHTML = `
            <div class="track-info">
              <strong>${track.title || track.name}</strong>
              <span>${track.artist || 'Unknown Artist'} - ${track.album || 'Unknown Album'}</span>
            </div>
            <div class="playlist-actions">
                <button class="add-to-playlist-btn" data-track-id="${track.id}" title="Add to Playlist">➕</button>
            </div>
          `;
          libraryList.appendChild(li);

          // Add to playlist button listener
          li.querySelector('.add-to-playlist-btn').addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent li click
            const trackIdToAdd = parseFloat(event.target.dataset.trackId);
            const trackToAdd = library.find(t => t.id === trackIdToAdd);
            if (trackToAdd && !playlist.some(p => p.id === trackToAdd.id)) { // Prevent duplicates
                playlist.push(trackToAdd);
                renderPlaylist();
                showTab('playlist-tab'); // Switch to playlist tab after adding
            }
          });
        });
      }

      function renderPlaylist() {
        playlistList.innerHTML = '';
        if (playlist.length === 0) {
          noPlaylistMessage.style.display = 'block';
          return;
        }
        noPlaylistMessage.style.display = 'none';

        playlist.forEach((track, index) => {
          const li = document.createElement('li');
          li.dataset.index = index;
          li.classList.toggle('playing', index === currentTrackIndex && currentTrackType !== 'youtube'); // Highlight current track

          let trackDisplayTitle = track.title || track.name;
          if (track.type === 'youtube') {
              trackDisplayTitle = `YouTube: ${track.url || track.videoId}`; // Display YouTube info
          }

          li.innerHTML = `
            <div class="track-info">
              <strong>${trackDisplayTitle}</strong>
              <span>${track.artist ? `${track.artist} - ${track.album || 'Unknown Album'}` : (track.type === 'youtube' ? 'YouTube Audio' : 'Unknown Artist - Unknown Album')}</span>
            </div>
            <div class="playlist-actions">
              <button class="remove-from-playlist-btn" data-index="${index}" title="Remove from Playlist">🗑️</button>
            </div>
          `;
          playlistList.appendChild(li);

          li.addEventListener('click', () => {
            // If clicking the currently playing YouTube track, do nothing
            if (currentTrackType === 'youtube' && track.type === 'youtube') {
                // You could add logic here to re-play the YouTube track or seek
                return;
            }

            currentTrackIndex = index;
            // If switching from YouTube to local/stream, pause YouTube
            if (currentTrackType === 'youtube' && youtubePlayer) {
                youtubePlayer.pauseVideo();
            }
            playCurrentTrack();
            renderPlaylist(); // Re-render to update highlight
          });

          li.querySelector('.remove-from-playlist-btn').addEventListener('click', (event) => {
            event.stopPropagation();
            const indexToRemove = parseInt(event.target.dataset.index);
            if (indexToRemove === currentTrackIndex) {
              pauseCurrentTrack(); // Pause if current track is removed
              currentTrackIndex = -1;
              currentTrackTitle.textContent = "No track playing";
              currentTrackArtist.textContent = "";
              progressBar.style.width = '0%';
              currentTimeSpan.textContent = '0:00';
              durationSpan.textContent = '0:00';
              if (currentTrackType === 'youtube' && youtubePlayer) {
                  youtubePlayer.stopVideo(); // Stop YouTube if it was playing
              }
              currentTrackType = 'local'; // Reset type
            } else if (indexToRemove < currentTrackIndex) {
              currentTrackIndex--; // Adjust index if a preceding track is removed
            }
            playlist.splice(indexToRemove, 1);
            renderPlaylist();
          });
        });
      }

      function showTab(tabId) {
        const tabs = document.querySelectorAll('.tab-content');
        tabs.forEach(tab => tab.classList.remove('active'));
        document.getElementById(tabId).classList.add('active');

        const tabButtons = document.querySelectorAll('.tab-button');
        tabButtons.forEach(btn => btn.classList.remove('active'));
        document.getElementById(`${tabId}-btn`).classList.add('active');
      }

      function clearFilter() {
        renderLibraryList('all'); // Go back to showing all songs
      }

      // --- Event Listeners ---
      function initEventListeners() {
        addMusicFileInput.addEventListener('change', (event) => {
          addLocalFiles(event.target.files);
        });

        playStreamBtn.addEventListener('click', () => {
          const url = streamUrlInput.value.trim();
          if (url) {
            // Pause current local/youtube playback if any
            if (!audio.paused) {
                audio.pause();
            }
            if (currentTrackType === 'youtube' && youtubePlayer) {
                youtubePlayer.pauseVideo();
            }

            const streamTrack = {
              id: Date.now() + Math.random(),
              name: url.split('/').pop() || 'Streaming Audio',
              url: url,
              type: 'stream',
              title: url.split('/').pop() || 'Streaming Audio',
              artist: 'Remote',
              album: 'Live Stream',
              genre: 'Stream'
            };
            // Add stream to playlist
            playlist.push(streamTrack);
            currentTrackIndex = playlist.length - 1; // Play the newly added stream
            playCurrentTrack();
            renderPlaylist();
            showTab('playlist-tab');
            streamUrlInput.value = ''; // Clear input
          } else {
            alert('Please enter a stream URL.');
          }
        });

        // Event listener for playing YouTube audio
        playYoutubeBtn.addEventListener('click', () => {
            const youtubeUrl = youtubeUrlInput.value.trim();
            const videoId = extractYouTubeVideoId(youtubeUrl);
            if (videoId) {
                const youtubeTrack = {
                    id: videoId, // Use videoId as ID for YouTube tracks
                    name: `YouTube: ${videoId}`,
                    url: youtubeUrl,
                    videoId: videoId,
                    type: 'youtube',
                    title: 'YouTube Video', // Title can be fetched dynamically if needed
                    artist: 'YouTube',
                    album: 'YouTube',
                    genre: 'Video'
                };
                // Check if this YouTube video is already in the playlist
                const existingIndex = playlist.findIndex(t => t.type === 'youtube' && t.videoId === videoId);
                if (existingIndex === -1) {
                    playlist.push(youtubeTrack);
                    currentTrackIndex = playlist.length - 1; // Play the newly added YouTube track
                } else {
                    currentTrackIndex = existingIndex; // Play existing YouTube track
                }

                playYouTubeAudio(videoId); // Start playing via YouTube API
                renderPlaylist();
                showTab('playlist-tab');
                youtubeUrlInput.value = ''; // Clear input
            } else {
                alert('Please enter a valid YouTube video URL.');
            }
        });


        playPauseBtn.addEventListener('click', togglePlayPause);
        prevBtn.addEventListener('click', playPrevTrack);
        nextBtn.addEventListener('click', playNextTrack);

        audio.addEventListener('timeupdate', updateProgressBarAndTimer);
        audio.addEventListener('ended', playNextTrack); // Auto-play next track

        volumeSlider.addEventListener('input', (event) => {
          const volume = event.target.value / 100;
          audio.volume = volume;
          if (youtubePlayer && typeof youtubePlayer.setVolume === 'function') {
              youtubePlayer.setVolume(event.target.value); // Set YouTube player volume
          }
        });

        progressBarContainer.addEventListener('click', (event) => {
          const clickX = event.clientX - progressBarContainer.getBoundingClientRect().left;
          const percentage = clickX / progressBarContainer.offsetWidth;
          let newTime;

          if (currentTrackType === 'youtube' && youtubePlayer && youtubePlayer.getDuration() > 0) {
              newTime = youtubePlayer.getDuration() * percentage;
              youtubePlayer.seekTo(newTime, true);
          } else if (audio && !isNaN(audio.duration) && audio.duration > 0) {
              newTime = audio.duration * percentage;
              audio.currentTime = newTime;
          }
        });

        // Tab button event listeners
        libraryTabBtn.addEventListener('click', () => showTab('library-tab')); // Renamed
        playlistTabBtn.addEventListener('click', () => showTab('playlist-tab'));

        // Library Filter Nav buttons
        viewAllSongsBtn.addEventListener('click', () => renderLibraryList('all'));
        viewAlbumsBtn.addEventListener('click', () => renderLibraryList('albums'));
        viewArtistsBtn.addEventListener('click', () => renderLibraryList('artists'));
        viewGenresBtn.addEventListener('click', () => renderLibraryList('genres'));
        clearFilterBtn.addEventListener('click', clearFilter);
      }

      // --- Initialization ---
      async function init() {
        await openIndexedDB();
        await loadTracksFromIndexedDB(); // Load existing tracks from IndexedDB

        initEventListeners();

        // Set initial active tab
        showTab('playlist-tab'); // Default to showing the playlist tab

        renderPlaylist(); // Render playlist based on loaded data
        renderLibraryList('all'); // Render library list with 'all' songs view initially

        // Ensure visualizer is set up and connected
        setupVisualizer();
        // If an audio source is active, connect it. For initial load, it might not be.
        // The connectSourceToVisualizer is called in playCurrentTrack.
      }

      init();

      // Service Worker Registration (existing code)
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js')
            .then((registration) => {
              console.log('Service Worker registered with scope:', registration.scope);
            })
            .catch((error) => {
              console.error('Service Worker registration failed:', error);
            });
        });
      }
    })();
  </script>
</body>
</html>